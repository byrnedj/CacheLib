/**
 * Autogenerated by Thrift for DataTypeBench.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */
#pragma once

#include <thrift/lib/cpp2/gen/module_types_h.h>



namespace apache {
namespace thrift {
namespace tag {
struct m;
struct m;
} // namespace tag
namespace detail {
#ifndef APACHE_THRIFT_ACCESSOR_m
#define APACHE_THRIFT_ACCESSOR_m
APACHE_THRIFT_DEFINE_ACCESSOR(m);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_m
#define APACHE_THRIFT_ACCESSOR_m
APACHE_THRIFT_DEFINE_ACCESSOR(m);
#endif
} // namespace detail
} // namespace thrift
} // namespace apache

// BEGIN declare_enums

// END declare_enums
// BEGIN forward_declare
namespace facebook { namespace cachelib { namespace datatypebench {
class StdMap;
class StdUnorderedMap;
}}} // facebook::cachelib::datatypebench
// END forward_declare
// BEGIN typedefs

// END typedefs
// BEGIN hash_and_equal_to
// END hash_and_equal_to
namespace facebook { namespace cachelib { namespace datatypebench {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;
}}} // facebook::cachelib::datatypebench
namespace facebook { namespace cachelib { namespace datatypebench {
class StdMap final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = StdMap;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  StdMap() {
  }
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  StdMap(apache::thrift::FragileConstructor, ::std::map<::std::int32_t, ::std::string> m__arg);

  StdMap(StdMap&&) noexcept;

  StdMap(const StdMap& src);


  StdMap& operator=(StdMap&&) noexcept;
  StdMap& operator=(const StdMap& src);
  void __clear();
 public:
  ::std::map<::std::int32_t, ::std::string> m;

 public:

  bool operator==(const StdMap&) const;
  bool operator<(const StdMap&) const;

  template <typename..., typename T = ::std::map<::std::int32_t, ::std::string>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> m_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->m};
  }

  template <typename..., typename T = ::std::map<::std::int32_t, ::std::string>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> m_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->m)};
  }

  template <typename..., typename T = ::std::map<::std::int32_t, ::std::string>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> m_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->m};
  }

  template <typename..., typename T = ::std::map<::std::int32_t, ::std::string>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> m_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->m)};
  }
  const ::std::map<::std::int32_t, ::std::string>& get_m() const&;
  ::std::map<::std::int32_t, ::std::string> get_m() &&;

  template <typename T_StdMap_m_struct_setter = ::std::map<::std::int32_t, ::std::string>>
  [[deprecated("Use `FOO.m_ref() = BAR;` instead of `FOO.set_m(BAR);`")]]
  ::std::map<::std::int32_t, ::std::string>& set_m(T_StdMap_m_struct_setter&& m_) {
    m_ref() = std::forward<T_StdMap_m_struct_setter>(m_);
    return m;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<StdMap>;
  friend void swap(StdMap& a, StdMap& b);
};

template <class Protocol_>
uint32_t StdMap::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // facebook::cachelib::datatypebench
namespace facebook { namespace cachelib { namespace datatypebench {
class StdUnorderedMap final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = StdUnorderedMap;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  StdUnorderedMap() {
  }
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  StdUnorderedMap(apache::thrift::FragileConstructor, std::unordered_map<::std::int32_t, ::std::string> m__arg);

  StdUnorderedMap(StdUnorderedMap&&) noexcept;

  StdUnorderedMap(const StdUnorderedMap& src);


  StdUnorderedMap& operator=(StdUnorderedMap&&) noexcept;
  StdUnorderedMap& operator=(const StdUnorderedMap& src);
  void __clear();
 public:
  std::unordered_map<::std::int32_t, ::std::string> m;

 public:

  bool operator==(const StdUnorderedMap&) const;
  bool operator<(const StdUnorderedMap&) const;

  template <typename..., typename T = std::unordered_map<::std::int32_t, ::std::string>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> m_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->m};
  }

  template <typename..., typename T = std::unordered_map<::std::int32_t, ::std::string>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> m_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{std::move(this->m)};
  }

  template <typename..., typename T = std::unordered_map<::std::int32_t, ::std::string>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> m_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->m};
  }

  template <typename..., typename T = std::unordered_map<::std::int32_t, ::std::string>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> m_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{std::move(this->m)};
  }
  const std::unordered_map<::std::int32_t, ::std::string>& get_m() const&;
  std::unordered_map<::std::int32_t, ::std::string> get_m() &&;

  template <typename T_StdUnorderedMap_m_struct_setter = std::unordered_map<::std::int32_t, ::std::string>>
  [[deprecated("Use `FOO.m_ref() = BAR;` instead of `FOO.set_m(BAR);`")]]
  std::unordered_map<::std::int32_t, ::std::string>& set_m(T_StdUnorderedMap_m_struct_setter&& m_) {
    m_ref() = std::forward<T_StdUnorderedMap_m_struct_setter>(m_);
    return m;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<StdUnorderedMap>;
  friend void swap(StdUnorderedMap& a, StdUnorderedMap& b);
};

template <class Protocol_>
uint32_t StdUnorderedMap::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // facebook::cachelib::datatypebench
