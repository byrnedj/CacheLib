/**
 * Autogenerated by Thrift for objects.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */
#pragma once

#include <thrift/lib/cpp2/visitation/visit_by_thrift_field_metadata.h>
#include "objects_metadata.h"

namespace apache {
namespace thrift {
namespace detail {

template <>
struct VisitByFieldId<::facebook::cachelib::navy::serialization::IndexEntry> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, int32_t fieldId, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).key_ref());
    case 2:
      return f(1, static_cast<T&&>(t).address_ref());
    case 3:
      return f(2, static_cast<T&&>(t).sizeHint_ref());
    case 4:
      return f(3, static_cast<T&&>(t).totalHits_ref());
    case 5:
      return f(4, static_cast<T&&>(t).currentHits_ref());
    default:
      throwInvalidThriftId(fieldId, "::facebook::cachelib::navy::serialization::IndexEntry");
    }
  }
};

template <>
struct VisitByFieldId<::facebook::cachelib::navy::serialization::IndexBucket> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, int32_t fieldId, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).bucketId_ref());
    case 2:
      return f(1, static_cast<T&&>(t).entries_ref());
    default:
      throwInvalidThriftId(fieldId, "::facebook::cachelib::navy::serialization::IndexBucket");
    }
  }
};

template <>
struct VisitByFieldId<::facebook::cachelib::navy::serialization::Region> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, int32_t fieldId, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).regionId_ref());
    case 2:
      return f(1, static_cast<T&&>(t).lastEntryEndOffset_ref());
    case 3:
      return f(2, static_cast<T&&>(t).classId_ref());
    case 4:
      return f(3, static_cast<T&&>(t).numItems_ref());
    case 5:
      return f(4, static_cast<T&&>(t).pinned_ref());
    case 6:
      return f(5, static_cast<T&&>(t).priority_ref());
    default:
      throwInvalidThriftId(fieldId, "::facebook::cachelib::navy::serialization::Region");
    }
  }
};

template <>
struct VisitByFieldId<::facebook::cachelib::navy::serialization::RegionData> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, int32_t fieldId, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).regions_ref());
    case 2:
      return f(1, static_cast<T&&>(t).regionSize_ref());
    default:
      throwInvalidThriftId(fieldId, "::facebook::cachelib::navy::serialization::RegionData");
    }
  }
};

template <>
struct VisitByFieldId<::facebook::cachelib::navy::serialization::FifoPolicyNodeData> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, int32_t fieldId, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).idx_ref());
    case 2:
      return f(1, static_cast<T&&>(t).trackTime_ref());
    default:
      throwInvalidThriftId(fieldId, "::facebook::cachelib::navy::serialization::FifoPolicyNodeData");
    }
  }
};

template <>
struct VisitByFieldId<::facebook::cachelib::navy::serialization::FifoPolicyData> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, int32_t fieldId, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).queue_ref());
    default:
      throwInvalidThriftId(fieldId, "::facebook::cachelib::navy::serialization::FifoPolicyData");
    }
  }
};

template <>
struct VisitByFieldId<::facebook::cachelib::navy::serialization::AccessStats> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, int32_t fieldId, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).totalHits_ref());
    case 2:
      return f(1, static_cast<T&&>(t).currHits_ref());
    case 3:
      return f(2, static_cast<T&&>(t).numReinsertions_ref());
    default:
      throwInvalidThriftId(fieldId, "::facebook::cachelib::navy::serialization::AccessStats");
    }
  }
};

template <>
struct VisitByFieldId<::facebook::cachelib::navy::serialization::AccessStatsPair> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, int32_t fieldId, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).key_ref());
    case 2:
      return f(1, static_cast<T&&>(t).stats_ref());
    default:
      throwInvalidThriftId(fieldId, "::facebook::cachelib::navy::serialization::AccessStatsPair");
    }
  }
};

template <>
struct VisitByFieldId<::facebook::cachelib::navy::serialization::AccessTracker> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, int32_t fieldId, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).deprecated_data_ref());
    case 2:
      return f(1, static_cast<T&&>(t).data_ref());
    default:
      throwInvalidThriftId(fieldId, "::facebook::cachelib::navy::serialization::AccessTracker");
    }
  }
};

template <>
struct VisitByFieldId<::facebook::cachelib::navy::serialization::BlockCacheConfig> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, int32_t fieldId, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).version_ref());
    case 2:
      return f(1, static_cast<T&&>(t).cacheBaseOffset_ref());
    case 3:
      return f(2, static_cast<T&&>(t).cacheSize_ref());
    case 4:
      return f(3, static_cast<T&&>(t).allocAlignSize_ref());
    case 5:
      return f(4, static_cast<T&&>(t).sizeClasses_ref());
    case 6:
      return f(5, static_cast<T&&>(t).checksum_ref());
    case 7:
      return f(6, static_cast<T&&>(t).sizeDist_ref());
    case 8:
      return f(7, static_cast<T&&>(t).holeCount_ref());
    case 9:
      return f(8, static_cast<T&&>(t).holeSizeTotal_ref());
    case 10:
      return f(9, static_cast<T&&>(t).reinsertionPolicyEnabled_ref());
    default:
      throwInvalidThriftId(fieldId, "::facebook::cachelib::navy::serialization::BlockCacheConfig");
    }
  }
};

template <>
struct VisitByFieldId<::facebook::cachelib::navy::serialization::BigHashPersistentData> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, int32_t fieldId, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).version_ref());
    case 2:
      return f(1, static_cast<T&&>(t).generationTime_ref());
    case 3:
      return f(2, static_cast<T&&>(t).itemCount_ref());
    case 4:
      return f(3, static_cast<T&&>(t).bucketSize_ref());
    case 5:
      return f(4, static_cast<T&&>(t).cacheBaseOffset_ref());
    case 6:
      return f(5, static_cast<T&&>(t).numBuckets_ref());
    case 7:
      return f(6, static_cast<T&&>(t).sizeDist_ref());
    default:
      throwInvalidThriftId(fieldId, "::facebook::cachelib::navy::serialization::BigHashPersistentData");
    }
  }
};
} // namespace detail
} // namespace thrift
} // namespace apache
