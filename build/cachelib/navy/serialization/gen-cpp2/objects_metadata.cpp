/**
 * Autogenerated by Thrift for objects.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */
#include <thrift/lib/cpp2/gen/module_metadata_cpp.h>
#include "objects_metadata.h"

namespace apache {
namespace thrift {
namespace detail {
namespace md {
using ThriftMetadata = ::apache::thrift::metadata::ThriftMetadata;
using ThriftPrimitiveType = ::apache::thrift::metadata::ThriftPrimitiveType;
using ThriftType = ::apache::thrift::metadata::ThriftType;
using ThriftService = ::apache::thrift::metadata::ThriftService;
using ThriftServiceContext = ::apache::thrift::metadata::ThriftServiceContext;
using ThriftFunctionGenerator = void (*)(ThriftMetadata&, ThriftService&);


const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::facebook::cachelib::navy::serialization::IndexEntry>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("objects.IndexEntry", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& objects_IndexEntry = res.first->second;
  objects_IndexEntry.name_ref() = "objects.IndexEntry";
  objects_IndexEntry.is_union_ref() = false;
  static const EncodedThriftField
  objects_IndexEntry_fields[] = {
    {1, "key", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}},
    {2, "address", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}},
    {3, "sizeHint", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I16_TYPE), std::vector<ThriftConstStruct>{}},
    {4, "totalHits", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BYTE_TYPE), std::vector<ThriftConstStruct>{}},
    {5, "currentHits", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BYTE_TYPE), std::vector<ThriftConstStruct>{}},
  };
  for (const auto& f : objects_IndexEntry_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = f.id;
    field.name_ref() = f.name;
    field.is_optional_ref() = f.is_optional;
    f.metadata_type_interface->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = f.structured_annotations;
    objects_IndexEntry.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::facebook::cachelib::navy::serialization::IndexBucket>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("objects.IndexBucket", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& objects_IndexBucket = res.first->second;
  objects_IndexBucket.name_ref() = "objects.IndexBucket";
  objects_IndexBucket.is_union_ref() = false;
  static const EncodedThriftField
  objects_IndexBucket_fields[] = {
    {1, "bucketId", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}},
    {2, "entries", false, std::make_unique<List>(std::make_unique<Struct< ::facebook::cachelib::navy::serialization::IndexEntry>>("objects.IndexEntry")), std::vector<ThriftConstStruct>{}},
  };
  for (const auto& f : objects_IndexBucket_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = f.id;
    field.name_ref() = f.name;
    field.is_optional_ref() = f.is_optional;
    f.metadata_type_interface->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = f.structured_annotations;
    objects_IndexBucket.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::facebook::cachelib::navy::serialization::Region>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("objects.Region", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& objects_Region = res.first->second;
  objects_Region.name_ref() = "objects.Region";
  objects_Region.is_union_ref() = false;
  static const EncodedThriftField
  objects_Region_fields[] = {
    {1, "regionId", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}},
    {2, "lastEntryEndOffset", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}},
    {3, "classId", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}},
    {4, "numItems", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}},
    {5, "pinned", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}},
    {6, "priority", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}},
  };
  for (const auto& f : objects_Region_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = f.id;
    field.name_ref() = f.name;
    field.is_optional_ref() = f.is_optional;
    f.metadata_type_interface->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = f.structured_annotations;
    objects_Region.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::facebook::cachelib::navy::serialization::RegionData>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("objects.RegionData", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& objects_RegionData = res.first->second;
  objects_RegionData.name_ref() = "objects.RegionData";
  objects_RegionData.is_union_ref() = false;
  static const EncodedThriftField
  objects_RegionData_fields[] = {
    {1, "regions", false, std::make_unique<List>(std::make_unique<Struct< ::facebook::cachelib::navy::serialization::Region>>("objects.Region")), std::vector<ThriftConstStruct>{}},
    {2, "regionSize", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}},
  };
  for (const auto& f : objects_RegionData_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = f.id;
    field.name_ref() = f.name;
    field.is_optional_ref() = f.is_optional;
    f.metadata_type_interface->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = f.structured_annotations;
    objects_RegionData.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::facebook::cachelib::navy::serialization::FifoPolicyNodeData>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("objects.FifoPolicyNodeData", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& objects_FifoPolicyNodeData = res.first->second;
  objects_FifoPolicyNodeData.name_ref() = "objects.FifoPolicyNodeData";
  objects_FifoPolicyNodeData.is_union_ref() = false;
  static const EncodedThriftField
  objects_FifoPolicyNodeData_fields[] = {
    {1, "idx", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}},
    {2, "trackTime", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}},
  };
  for (const auto& f : objects_FifoPolicyNodeData_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = f.id;
    field.name_ref() = f.name;
    field.is_optional_ref() = f.is_optional;
    f.metadata_type_interface->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = f.structured_annotations;
    objects_FifoPolicyNodeData.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::facebook::cachelib::navy::serialization::FifoPolicyData>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("objects.FifoPolicyData", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& objects_FifoPolicyData = res.first->second;
  objects_FifoPolicyData.name_ref() = "objects.FifoPolicyData";
  objects_FifoPolicyData.is_union_ref() = false;
  static const EncodedThriftField
  objects_FifoPolicyData_fields[] = {
    {1, "queue", false, std::make_unique<List>(std::make_unique<Struct< ::facebook::cachelib::navy::serialization::FifoPolicyNodeData>>("objects.FifoPolicyNodeData")), std::vector<ThriftConstStruct>{}},
  };
  for (const auto& f : objects_FifoPolicyData_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = f.id;
    field.name_ref() = f.name;
    field.is_optional_ref() = f.is_optional;
    f.metadata_type_interface->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = f.structured_annotations;
    objects_FifoPolicyData.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::facebook::cachelib::navy::serialization::AccessStats>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("objects.AccessStats", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& objects_AccessStats = res.first->second;
  objects_AccessStats.name_ref() = "objects.AccessStats";
  objects_AccessStats.is_union_ref() = false;
  static const EncodedThriftField
  objects_AccessStats_fields[] = {
    {1, "totalHits", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BYTE_TYPE), std::vector<ThriftConstStruct>{}},
    {2, "currHits", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BYTE_TYPE), std::vector<ThriftConstStruct>{}},
    {3, "numReinsertions", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BYTE_TYPE), std::vector<ThriftConstStruct>{}},
  };
  for (const auto& f : objects_AccessStats_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = f.id;
    field.name_ref() = f.name;
    field.is_optional_ref() = f.is_optional;
    f.metadata_type_interface->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = f.structured_annotations;
    objects_AccessStats.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::facebook::cachelib::navy::serialization::AccessStatsPair>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("objects.AccessStatsPair", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& objects_AccessStatsPair = res.first->second;
  objects_AccessStatsPair.name_ref() = "objects.AccessStatsPair";
  objects_AccessStatsPair.is_union_ref() = false;
  static const EncodedThriftField
  objects_AccessStatsPair_fields[] = {
    {1, "key", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}},
    {2, "stats", false, std::make_unique<Struct< ::facebook::cachelib::navy::serialization::AccessStats>>("objects.AccessStats"), std::vector<ThriftConstStruct>{}},
  };
  for (const auto& f : objects_AccessStatsPair_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = f.id;
    field.name_ref() = f.name;
    field.is_optional_ref() = f.is_optional;
    f.metadata_type_interface->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = f.structured_annotations;
    objects_AccessStatsPair.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::facebook::cachelib::navy::serialization::AccessTracker>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("objects.AccessTracker", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& objects_AccessTracker = res.first->second;
  objects_AccessTracker.name_ref() = "objects.AccessTracker";
  objects_AccessTracker.is_union_ref() = false;
  static const EncodedThriftField
  objects_AccessTracker_fields[] = {
    {1, "deprecated_data", false, std::make_unique<Map>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::make_unique<Struct< ::facebook::cachelib::navy::serialization::AccessStats>>("objects.AccessStats")), std::vector<ThriftConstStruct>{}},
    {2, "data", false, std::make_unique<List>(std::make_unique<Struct< ::facebook::cachelib::navy::serialization::AccessStatsPair>>("objects.AccessStatsPair")), std::vector<ThriftConstStruct>{}},
  };
  for (const auto& f : objects_AccessTracker_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = f.id;
    field.name_ref() = f.name;
    field.is_optional_ref() = f.is_optional;
    f.metadata_type_interface->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = f.structured_annotations;
    objects_AccessTracker.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::facebook::cachelib::navy::serialization::BlockCacheConfig>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("objects.BlockCacheConfig", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& objects_BlockCacheConfig = res.first->second;
  objects_BlockCacheConfig.name_ref() = "objects.BlockCacheConfig";
  objects_BlockCacheConfig.is_union_ref() = false;
  static const EncodedThriftField
  objects_BlockCacheConfig_fields[] = {
    {1, "version", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}},
    {2, "cacheBaseOffset", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}},
    {3, "cacheSize", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}},
    {4, "allocAlignSize", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}},
    {5, "sizeClasses", false, std::make_unique<Set>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE)), std::vector<ThriftConstStruct>{}},
    {6, "checksum", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}},
    {7, "sizeDist", false, std::make_unique<Map>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)), std::vector<ThriftConstStruct>{}},
    {8, "holeCount", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}},
    {9, "holeSizeTotal", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}},
    {10, "reinsertionPolicyEnabled", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BOOL_TYPE), std::vector<ThriftConstStruct>{}},
  };
  for (const auto& f : objects_BlockCacheConfig_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = f.id;
    field.name_ref() = f.name;
    field.is_optional_ref() = f.is_optional;
    f.metadata_type_interface->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = f.structured_annotations;
    objects_BlockCacheConfig.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::facebook::cachelib::navy::serialization::BigHashPersistentData>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("objects.BigHashPersistentData", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& objects_BigHashPersistentData = res.first->second;
  objects_BigHashPersistentData.name_ref() = "objects.BigHashPersistentData";
  objects_BigHashPersistentData.is_union_ref() = false;
  static const EncodedThriftField
  objects_BigHashPersistentData_fields[] = {
    {1, "version", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I32_TYPE), std::vector<ThriftConstStruct>{}},
    {2, "generationTime", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}},
    {3, "itemCount", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}},
    {4, "bucketSize", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}},
    {5, "cacheBaseOffset", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}},
    {6, "numBuckets", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}},
    {7, "sizeDist", false, std::make_unique<Map>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)), std::vector<ThriftConstStruct>{}},
  };
  for (const auto& f : objects_BigHashPersistentData_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = f.id;
    field.name_ref() = f.name;
    field.is_optional_ref() = f.is_optional;
    f.metadata_type_interface->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = f.structured_annotations;
    objects_BigHashPersistentData.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}

} // namespace md
} // namespace detail
} // namespace thrift
} // namespace apache
