/**
 * Autogenerated by Thrift for objects.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */
#include "objects_types.h"
#include "objects_types.tcc"

#include <thrift/lib/cpp2/gen/module_types_cpp.h>

#include "objects_data.h"


namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::cachelib::navy::serialization::IndexEntry>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::facebook::cachelib::navy::serialization::IndexEntry>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace cachelib { namespace navy { namespace serialization {

IndexEntry::IndexEntry(const IndexEntry&) = default;
IndexEntry& IndexEntry::operator=(const IndexEntry&) = default;
IndexEntry::IndexEntry(IndexEntry&& other) noexcept  :
    key(std::move(other.key)),
    address(std::move(other.address)),
    __fbthrift_field_sizeHint(std::move(other.__fbthrift_field_sizeHint)),
    __fbthrift_field_totalHits(std::move(other.__fbthrift_field_totalHits)),
    __fbthrift_field_currentHits(std::move(other.__fbthrift_field_currentHits)),
    __isset(other.__isset) {
}

IndexEntry& IndexEntry::operator=(FOLLY_MAYBE_UNUSED IndexEntry&& other) noexcept {
    this->key = std::move(other.key);
    this->address = std::move(other.address);
    this->__fbthrift_field_sizeHint = std::move(other.__fbthrift_field_sizeHint);
    this->__fbthrift_field_totalHits = std::move(other.__fbthrift_field_totalHits);
    this->__fbthrift_field_currentHits = std::move(other.__fbthrift_field_currentHits);
    __isset = other.__isset;
    return *this;
}


IndexEntry::IndexEntry(apache::thrift::FragileConstructor, ::std::int32_t key__arg, ::std::int32_t address__arg, ::std::int16_t sizeHint__arg, ::std::int8_t totalHits__arg, ::std::int8_t currentHits__arg) :
    key(std::move(key__arg)),
    address(std::move(address__arg)),
    __fbthrift_field_sizeHint(std::move(sizeHint__arg)),
    __fbthrift_field_totalHits(std::move(totalHits__arg)),
    __fbthrift_field_currentHits(std::move(currentHits__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
}


void IndexEntry::__clear() {
  // clear all fields
  this->key = static_cast<::std::int32_t>(0);
  this->address = static_cast<::std::int32_t>(0);
  this->__fbthrift_field_sizeHint = static_cast<::std::int16_t>(0);
  this->__fbthrift_field_totalHits = static_cast<::std::int8_t>(0);
  this->__fbthrift_field_currentHits = static_cast<::std::int8_t>(0);
  __isset = {};
}

bool IndexEntry::operator==(const IndexEntry& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.key_ref() == rhs.key_ref())) {
    return false;
  }
  if (!(lhs.address_ref() == rhs.address_ref())) {
    return false;
  }
  if (!(lhs.sizeHint_ref() == rhs.sizeHint_ref())) {
    return false;
  }
  if (!(lhs.totalHits_ref() == rhs.totalHits_ref())) {
    return false;
  }
  if (!(lhs.currentHits_ref() == rhs.currentHits_ref())) {
    return false;
  }
  return true;
}

bool IndexEntry::operator<(const IndexEntry& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.key_ref() == rhs.key_ref())) {
    return lhs.key_ref() < rhs.key_ref();
  }
  if (!(lhs.address_ref() == rhs.address_ref())) {
    return lhs.address_ref() < rhs.address_ref();
  }
  if (!(lhs.sizeHint_ref() == rhs.sizeHint_ref())) {
    return lhs.sizeHint_ref() < rhs.sizeHint_ref();
  }
  if (!(lhs.totalHits_ref() == rhs.totalHits_ref())) {
    return lhs.totalHits_ref() < rhs.totalHits_ref();
  }
  if (!(lhs.currentHits_ref() == rhs.currentHits_ref())) {
    return lhs.currentHits_ref() < rhs.currentHits_ref();
  }
  return false;
}


void swap(IndexEntry& a, IndexEntry& b) {
  using ::std::swap;
  swap(a.key_ref().value(), b.key_ref().value());
  swap(a.address_ref().value(), b.address_ref().value());
  swap(a.sizeHint_ref().value(), b.sizeHint_ref().value());
  swap(a.totalHits_ref().value(), b.totalHits_ref().value());
  swap(a.currentHits_ref().value(), b.currentHits_ref().value());
  swap(a.__isset, b.__isset);
}

template void IndexEntry::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t IndexEntry::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t IndexEntry::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t IndexEntry::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void IndexEntry::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t IndexEntry::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t IndexEntry::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t IndexEntry::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void IndexEntry::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t IndexEntry::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t IndexEntry::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t IndexEntry::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;



}}}} // facebook::cachelib::navy::serialization

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::cachelib::navy::serialization::IndexBucket>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::facebook::cachelib::navy::serialization::IndexBucket>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace cachelib { namespace navy { namespace serialization {

IndexBucket::IndexBucket(const IndexBucket&) = default;
IndexBucket& IndexBucket::operator=(const IndexBucket&) = default;
IndexBucket::IndexBucket(IndexBucket&& other) noexcept  :
    bucketId(std::move(other.bucketId)),
    entries(std::move(other.entries)) {
}

IndexBucket& IndexBucket::operator=(FOLLY_MAYBE_UNUSED IndexBucket&& other) noexcept {
    this->bucketId = std::move(other.bucketId);
    this->entries = std::move(other.entries);
    return *this;
}


IndexBucket::IndexBucket(apache::thrift::FragileConstructor, ::std::int32_t bucketId__arg, ::std::vector<::facebook::cachelib::navy::serialization::IndexEntry> entries__arg) :
    bucketId(std::move(bucketId__arg)),
    entries(std::move(entries__arg)) {
}


void IndexBucket::__clear() {
  // clear all fields
  this->bucketId = static_cast<::std::int32_t>(0);
  this->entries.clear();
}

bool IndexBucket::operator==(const IndexBucket& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.bucketId_ref() == rhs.bucketId_ref())) {
    return false;
  }
  if (!(lhs.entries_ref() == rhs.entries_ref())) {
    return false;
  }
  return true;
}

bool IndexBucket::operator<(const IndexBucket& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.bucketId_ref() == rhs.bucketId_ref())) {
    return lhs.bucketId_ref() < rhs.bucketId_ref();
  }
  if (!(lhs.entries_ref() == rhs.entries_ref())) {
    return lhs.entries_ref() < rhs.entries_ref();
  }
  return false;
}

const ::std::vector<::facebook::cachelib::navy::serialization::IndexEntry>& IndexBucket::get_entries() const& {
  return entries;
}

::std::vector<::facebook::cachelib::navy::serialization::IndexEntry> IndexBucket::get_entries() && {
  return std::move(entries);
}


void swap(IndexBucket& a, IndexBucket& b) {
  using ::std::swap;
  swap(a.bucketId_ref().value(), b.bucketId_ref().value());
  swap(a.entries_ref().value(), b.entries_ref().value());
}

template void IndexBucket::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t IndexBucket::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t IndexBucket::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t IndexBucket::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void IndexBucket::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t IndexBucket::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t IndexBucket::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t IndexBucket::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void IndexBucket::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t IndexBucket::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t IndexBucket::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t IndexBucket::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        IndexBucket,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<::facebook::cachelib::navy::serialization::IndexEntry>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        IndexBucket,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<::facebook::cachelib::navy::serialization::IndexEntry>>,
    "inconsistent use of nimble option");

}}}} // facebook::cachelib::navy::serialization

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::cachelib::navy::serialization::Region>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::facebook::cachelib::navy::serialization::Region>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace cachelib { namespace navy { namespace serialization {


Region::Region(apache::thrift::FragileConstructor, ::std::int32_t regionId__arg, ::std::int32_t lastEntryEndOffset__arg, ::std::int32_t classId__arg, ::std::int32_t numItems__arg, bool pinned__arg, ::std::int32_t priority__arg) :
    regionId(std::move(regionId__arg)),
    lastEntryEndOffset(std::move(lastEntryEndOffset__arg)),
    classId(std::move(classId__arg)),
    numItems(std::move(numItems__arg)),
    pinned(std::move(pinned__arg)),
    __fbthrift_field_priority(std::move(priority__arg)) {
  __isset.set(folly::index_constant<0>(), true);
}


void Region::__clear() {
  // clear all fields
  this->regionId = static_cast<::std::int32_t>(0);
  this->lastEntryEndOffset = static_cast<::std::int32_t>(0);
  this->classId = static_cast<::std::int32_t>(0);
  this->numItems = static_cast<::std::int32_t>(0);
  this->pinned = static_cast<bool>(false);
  this->__fbthrift_field_priority = static_cast<::std::int32_t>(0);
  __isset = {};
}

bool Region::operator==(const Region& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.regionId_ref() == rhs.regionId_ref())) {
    return false;
  }
  if (!(lhs.lastEntryEndOffset_ref() == rhs.lastEntryEndOffset_ref())) {
    return false;
  }
  if (!(lhs.classId_ref() == rhs.classId_ref())) {
    return false;
  }
  if (!(lhs.numItems_ref() == rhs.numItems_ref())) {
    return false;
  }
  if (!(lhs.pinned_ref() == rhs.pinned_ref())) {
    return false;
  }
  if (!(lhs.priority_ref() == rhs.priority_ref())) {
    return false;
  }
  return true;
}

bool Region::operator<(const Region& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.regionId_ref() == rhs.regionId_ref())) {
    return lhs.regionId_ref() < rhs.regionId_ref();
  }
  if (!(lhs.lastEntryEndOffset_ref() == rhs.lastEntryEndOffset_ref())) {
    return lhs.lastEntryEndOffset_ref() < rhs.lastEntryEndOffset_ref();
  }
  if (!(lhs.classId_ref() == rhs.classId_ref())) {
    return lhs.classId_ref() < rhs.classId_ref();
  }
  if (!(lhs.numItems_ref() == rhs.numItems_ref())) {
    return lhs.numItems_ref() < rhs.numItems_ref();
  }
  if (!(lhs.pinned_ref() == rhs.pinned_ref())) {
    return lhs.pinned_ref() < rhs.pinned_ref();
  }
  if (!(lhs.priority_ref() == rhs.priority_ref())) {
    return lhs.priority_ref() < rhs.priority_ref();
  }
  return false;
}


void swap(Region& a, Region& b) {
  using ::std::swap;
  swap(a.regionId_ref().value(), b.regionId_ref().value());
  swap(a.lastEntryEndOffset_ref().value(), b.lastEntryEndOffset_ref().value());
  swap(a.classId_ref().value(), b.classId_ref().value());
  swap(a.numItems_ref().value(), b.numItems_ref().value());
  swap(a.pinned_ref().value(), b.pinned_ref().value());
  swap(a.priority_ref().value(), b.priority_ref().value());
  swap(a.__isset, b.__isset);
}

template void Region::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t Region::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t Region::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t Region::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void Region::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t Region::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t Region::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t Region::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void Region::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t Region::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t Region::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t Region::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;



}}}} // facebook::cachelib::navy::serialization

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::cachelib::navy::serialization::RegionData>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::facebook::cachelib::navy::serialization::RegionData>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace cachelib { namespace navy { namespace serialization {

RegionData::RegionData(const RegionData&) = default;
RegionData& RegionData::operator=(const RegionData&) = default;
RegionData::RegionData(RegionData&& other) noexcept  :
    regions(std::move(other.regions)),
    regionSize(std::move(other.regionSize)) {
}

RegionData& RegionData::operator=(FOLLY_MAYBE_UNUSED RegionData&& other) noexcept {
    this->regions = std::move(other.regions);
    this->regionSize = std::move(other.regionSize);
    return *this;
}


RegionData::RegionData(apache::thrift::FragileConstructor, ::std::vector<::facebook::cachelib::navy::serialization::Region> regions__arg, ::std::int32_t regionSize__arg) :
    regions(std::move(regions__arg)),
    regionSize(std::move(regionSize__arg)) {
}


void RegionData::__clear() {
  // clear all fields
  this->regions.clear();
  this->regionSize = static_cast<::std::int32_t>(0);
}

bool RegionData::operator==(const RegionData& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.regions_ref() == rhs.regions_ref())) {
    return false;
  }
  if (!(lhs.regionSize_ref() == rhs.regionSize_ref())) {
    return false;
  }
  return true;
}

bool RegionData::operator<(const RegionData& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.regions_ref() == rhs.regions_ref())) {
    return lhs.regions_ref() < rhs.regions_ref();
  }
  if (!(lhs.regionSize_ref() == rhs.regionSize_ref())) {
    return lhs.regionSize_ref() < rhs.regionSize_ref();
  }
  return false;
}

const ::std::vector<::facebook::cachelib::navy::serialization::Region>& RegionData::get_regions() const& {
  return regions;
}

::std::vector<::facebook::cachelib::navy::serialization::Region> RegionData::get_regions() && {
  return std::move(regions);
}


void swap(RegionData& a, RegionData& b) {
  using ::std::swap;
  swap(a.regions_ref().value(), b.regions_ref().value());
  swap(a.regionSize_ref().value(), b.regionSize_ref().value());
}

template void RegionData::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t RegionData::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t RegionData::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t RegionData::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void RegionData::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t RegionData::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t RegionData::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t RegionData::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void RegionData::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t RegionData::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t RegionData::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t RegionData::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        RegionData,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<::facebook::cachelib::navy::serialization::Region>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        RegionData,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<::facebook::cachelib::navy::serialization::Region>>,
    "inconsistent use of nimble option");

}}}} // facebook::cachelib::navy::serialization

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::cachelib::navy::serialization::FifoPolicyNodeData>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::facebook::cachelib::navy::serialization::FifoPolicyNodeData>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace cachelib { namespace navy { namespace serialization {


FifoPolicyNodeData::FifoPolicyNodeData(apache::thrift::FragileConstructor, ::std::int32_t idx__arg, ::std::int64_t trackTime__arg) :
    idx(std::move(idx__arg)),
    trackTime(std::move(trackTime__arg)) {
}


void FifoPolicyNodeData::__clear() {
  // clear all fields
  this->idx = ::std::int32_t();
  this->trackTime = ::std::int64_t();
}

bool FifoPolicyNodeData::operator==(const FifoPolicyNodeData& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.idx_ref() == rhs.idx_ref())) {
    return false;
  }
  if (!(lhs.trackTime_ref() == rhs.trackTime_ref())) {
    return false;
  }
  return true;
}

bool FifoPolicyNodeData::operator<(const FifoPolicyNodeData& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.idx_ref() == rhs.idx_ref())) {
    return lhs.idx_ref() < rhs.idx_ref();
  }
  if (!(lhs.trackTime_ref() == rhs.trackTime_ref())) {
    return lhs.trackTime_ref() < rhs.trackTime_ref();
  }
  return false;
}


void swap(FifoPolicyNodeData& a, FifoPolicyNodeData& b) {
  using ::std::swap;
  swap(a.idx_ref().value(), b.idx_ref().value());
  swap(a.trackTime_ref().value(), b.trackTime_ref().value());
}

template void FifoPolicyNodeData::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t FifoPolicyNodeData::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t FifoPolicyNodeData::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t FifoPolicyNodeData::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void FifoPolicyNodeData::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t FifoPolicyNodeData::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t FifoPolicyNodeData::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t FifoPolicyNodeData::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void FifoPolicyNodeData::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t FifoPolicyNodeData::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t FifoPolicyNodeData::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t FifoPolicyNodeData::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;



}}}} // facebook::cachelib::navy::serialization

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::cachelib::navy::serialization::FifoPolicyData>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::facebook::cachelib::navy::serialization::FifoPolicyData>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace cachelib { namespace navy { namespace serialization {

FifoPolicyData::FifoPolicyData(const FifoPolicyData&) = default;
FifoPolicyData& FifoPolicyData::operator=(const FifoPolicyData&) = default;
FifoPolicyData::FifoPolicyData(FifoPolicyData&& other) noexcept  :
    queue(std::move(other.queue)) {
}

FifoPolicyData& FifoPolicyData::operator=(FOLLY_MAYBE_UNUSED FifoPolicyData&& other) noexcept {
    this->queue = std::move(other.queue);
    return *this;
}


FifoPolicyData::FifoPolicyData(apache::thrift::FragileConstructor, ::std::vector<::facebook::cachelib::navy::serialization::FifoPolicyNodeData> queue__arg) :
    queue(std::move(queue__arg)) {
}


void FifoPolicyData::__clear() {
  // clear all fields
  this->queue.clear();
}

bool FifoPolicyData::operator==(const FifoPolicyData& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.queue_ref() == rhs.queue_ref())) {
    return false;
  }
  return true;
}

bool FifoPolicyData::operator<(const FifoPolicyData& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.queue_ref() == rhs.queue_ref())) {
    return lhs.queue_ref() < rhs.queue_ref();
  }
  return false;
}

const ::std::vector<::facebook::cachelib::navy::serialization::FifoPolicyNodeData>& FifoPolicyData::get_queue() const& {
  return queue;
}

::std::vector<::facebook::cachelib::navy::serialization::FifoPolicyNodeData> FifoPolicyData::get_queue() && {
  return std::move(queue);
}


void swap(FifoPolicyData& a, FifoPolicyData& b) {
  using ::std::swap;
  swap(a.queue_ref().value(), b.queue_ref().value());
}

template void FifoPolicyData::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t FifoPolicyData::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t FifoPolicyData::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t FifoPolicyData::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void FifoPolicyData::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t FifoPolicyData::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t FifoPolicyData::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t FifoPolicyData::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void FifoPolicyData::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t FifoPolicyData::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t FifoPolicyData::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t FifoPolicyData::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        FifoPolicyData,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<::facebook::cachelib::navy::serialization::FifoPolicyNodeData>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        FifoPolicyData,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<::facebook::cachelib::navy::serialization::FifoPolicyNodeData>>,
    "inconsistent use of nimble option");

}}}} // facebook::cachelib::navy::serialization

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::cachelib::navy::serialization::AccessStats>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::facebook::cachelib::navy::serialization::AccessStats>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace cachelib { namespace navy { namespace serialization {

AccessStats::AccessStats(const AccessStats&) = default;
AccessStats& AccessStats::operator=(const AccessStats&) = default;
AccessStats::AccessStats(AccessStats&& other) noexcept  :
    __fbthrift_field_totalHits(std::move(other.__fbthrift_field_totalHits)),
    __fbthrift_field_currHits(std::move(other.__fbthrift_field_currHits)),
    __fbthrift_field_numReinsertions(std::move(other.__fbthrift_field_numReinsertions)),
    __isset(other.__isset) {
}

AccessStats& AccessStats::operator=(FOLLY_MAYBE_UNUSED AccessStats&& other) noexcept {
    this->__fbthrift_field_totalHits = std::move(other.__fbthrift_field_totalHits);
    this->__fbthrift_field_currHits = std::move(other.__fbthrift_field_currHits);
    this->__fbthrift_field_numReinsertions = std::move(other.__fbthrift_field_numReinsertions);
    __isset = other.__isset;
    return *this;
}


AccessStats::AccessStats(apache::thrift::FragileConstructor, ::std::int8_t totalHits__arg, ::std::int8_t currHits__arg, ::std::int8_t numReinsertions__arg) :
    __fbthrift_field_totalHits(std::move(totalHits__arg)),
    __fbthrift_field_currHits(std::move(currHits__arg)),
    __fbthrift_field_numReinsertions(std::move(numReinsertions__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
}


void AccessStats::__clear() {
  // clear all fields
  this->__fbthrift_field_totalHits = static_cast<::std::int8_t>(0);
  this->__fbthrift_field_currHits = static_cast<::std::int8_t>(0);
  this->__fbthrift_field_numReinsertions = static_cast<::std::int8_t>(0);
  __isset = {};
}

bool AccessStats::operator==(const AccessStats& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.totalHits_ref() == rhs.totalHits_ref())) {
    return false;
  }
  if (!(lhs.currHits_ref() == rhs.currHits_ref())) {
    return false;
  }
  if (!(lhs.numReinsertions_ref() == rhs.numReinsertions_ref())) {
    return false;
  }
  return true;
}

bool AccessStats::operator<(const AccessStats& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.totalHits_ref() == rhs.totalHits_ref())) {
    return lhs.totalHits_ref() < rhs.totalHits_ref();
  }
  if (!(lhs.currHits_ref() == rhs.currHits_ref())) {
    return lhs.currHits_ref() < rhs.currHits_ref();
  }
  if (!(lhs.numReinsertions_ref() == rhs.numReinsertions_ref())) {
    return lhs.numReinsertions_ref() < rhs.numReinsertions_ref();
  }
  return false;
}


void swap(AccessStats& a, AccessStats& b) {
  using ::std::swap;
  swap(a.totalHits_ref().value(), b.totalHits_ref().value());
  swap(a.currHits_ref().value(), b.currHits_ref().value());
  swap(a.numReinsertions_ref().value(), b.numReinsertions_ref().value());
  swap(a.__isset, b.__isset);
}

template void AccessStats::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t AccessStats::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t AccessStats::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t AccessStats::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void AccessStats::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t AccessStats::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t AccessStats::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t AccessStats::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void AccessStats::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t AccessStats::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t AccessStats::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t AccessStats::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;



}}}} // facebook::cachelib::navy::serialization

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::cachelib::navy::serialization::AccessStatsPair>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::facebook::cachelib::navy::serialization::AccessStatsPair>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace cachelib { namespace navy { namespace serialization {

AccessStatsPair::AccessStatsPair(const AccessStatsPair&) = default;
AccessStatsPair& AccessStatsPair::operator=(const AccessStatsPair&) = default;
AccessStatsPair::AccessStatsPair(AccessStatsPair&& other) noexcept  :
    __fbthrift_field_key(std::move(other.__fbthrift_field_key)),
    __fbthrift_field_stats(std::move(other.__fbthrift_field_stats)),
    __isset(other.__isset) {
}

AccessStatsPair& AccessStatsPair::operator=(FOLLY_MAYBE_UNUSED AccessStatsPair&& other) noexcept {
    this->__fbthrift_field_key = std::move(other.__fbthrift_field_key);
    this->__fbthrift_field_stats = std::move(other.__fbthrift_field_stats);
    __isset = other.__isset;
    return *this;
}


AccessStatsPair::AccessStatsPair(apache::thrift::FragileConstructor, ::std::int64_t key__arg, ::facebook::cachelib::navy::serialization::AccessStats stats__arg) :
    __fbthrift_field_key(std::move(key__arg)),
    __fbthrift_field_stats(std::move(stats__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
}


void AccessStatsPair::__clear() {
  // clear all fields
  this->__fbthrift_field_key = ::std::int64_t();
  this->__fbthrift_field_stats.__clear();
  __isset = {};
}

bool AccessStatsPair::operator==(const AccessStatsPair& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.key_ref() == rhs.key_ref())) {
    return false;
  }
  if (!(lhs.stats_ref() == rhs.stats_ref())) {
    return false;
  }
  return true;
}

bool AccessStatsPair::operator<(const AccessStatsPair& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.key_ref() == rhs.key_ref())) {
    return lhs.key_ref() < rhs.key_ref();
  }
  if (!(lhs.stats_ref() == rhs.stats_ref())) {
    return lhs.stats_ref() < rhs.stats_ref();
  }
  return false;
}

const ::facebook::cachelib::navy::serialization::AccessStats& AccessStatsPair::get_stats() const& {
  return __fbthrift_field_stats;
}

::facebook::cachelib::navy::serialization::AccessStats AccessStatsPair::get_stats() && {
  return std::move(__fbthrift_field_stats);
}


void swap(AccessStatsPair& a, AccessStatsPair& b) {
  using ::std::swap;
  swap(a.key_ref().value(), b.key_ref().value());
  swap(a.stats_ref().value(), b.stats_ref().value());
  swap(a.__isset, b.__isset);
}

template void AccessStatsPair::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t AccessStatsPair::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t AccessStatsPair::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t AccessStatsPair::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void AccessStatsPair::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t AccessStatsPair::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t AccessStatsPair::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t AccessStatsPair::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void AccessStatsPair::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t AccessStatsPair::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t AccessStatsPair::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t AccessStatsPair::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        AccessStatsPair,
        ::apache::thrift::type_class::structure,
        ::facebook::cachelib::navy::serialization::AccessStats>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        AccessStatsPair,
        ::apache::thrift::type_class::structure,
        ::facebook::cachelib::navy::serialization::AccessStats>,
    "inconsistent use of nimble option");

}}}} // facebook::cachelib::navy::serialization

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::cachelib::navy::serialization::AccessTracker>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::facebook::cachelib::navy::serialization::AccessTracker>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace cachelib { namespace navy { namespace serialization {

AccessTracker::AccessTracker(const AccessTracker&) = default;
AccessTracker& AccessTracker::operator=(const AccessTracker&) = default;
AccessTracker::AccessTracker(AccessTracker&& other) noexcept  :
    __fbthrift_field_deprecated_data(std::move(other.__fbthrift_field_deprecated_data)),
    __fbthrift_field_data(std::move(other.__fbthrift_field_data)),
    __isset(other.__isset) {
}

AccessTracker& AccessTracker::operator=(FOLLY_MAYBE_UNUSED AccessTracker&& other) noexcept {
    this->__fbthrift_field_deprecated_data = std::move(other.__fbthrift_field_deprecated_data);
    this->__fbthrift_field_data = std::move(other.__fbthrift_field_data);
    __isset = other.__isset;
    return *this;
}


AccessTracker::AccessTracker(apache::thrift::FragileConstructor, ::std::map<::std::int64_t, ::facebook::cachelib::navy::serialization::AccessStats> deprecated_data__arg, ::std::vector<::facebook::cachelib::navy::serialization::AccessStatsPair> data__arg) :
    __fbthrift_field_deprecated_data(std::move(deprecated_data__arg)),
    __fbthrift_field_data(std::move(data__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
}


void AccessTracker::__clear() {
  // clear all fields
  this->__fbthrift_field_deprecated_data.clear();
  this->__fbthrift_field_data.clear();
  __isset = {};
}

bool AccessTracker::operator==(const AccessTracker& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.deprecated_data_ref() == rhs.deprecated_data_ref())) {
    return false;
  }
  if (!(lhs.data_ref() == rhs.data_ref())) {
    return false;
  }
  return true;
}

bool AccessTracker::operator<(const AccessTracker& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.deprecated_data_ref() == rhs.deprecated_data_ref())) {
    return lhs.deprecated_data_ref() < rhs.deprecated_data_ref();
  }
  if (!(lhs.data_ref() == rhs.data_ref())) {
    return lhs.data_ref() < rhs.data_ref();
  }
  return false;
}

const ::std::map<::std::int64_t, ::facebook::cachelib::navy::serialization::AccessStats>& AccessTracker::get_deprecated_data() const& {
  return __fbthrift_field_deprecated_data;
}

::std::map<::std::int64_t, ::facebook::cachelib::navy::serialization::AccessStats> AccessTracker::get_deprecated_data() && {
  return std::move(__fbthrift_field_deprecated_data);
}

const ::std::vector<::facebook::cachelib::navy::serialization::AccessStatsPair>& AccessTracker::get_data() const& {
  return __fbthrift_field_data;
}

::std::vector<::facebook::cachelib::navy::serialization::AccessStatsPair> AccessTracker::get_data() && {
  return std::move(__fbthrift_field_data);
}


void swap(AccessTracker& a, AccessTracker& b) {
  using ::std::swap;
  swap(a.deprecated_data_ref().value(), b.deprecated_data_ref().value());
  swap(a.data_ref().value(), b.data_ref().value());
  swap(a.__isset, b.__isset);
}

template void AccessTracker::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t AccessTracker::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t AccessTracker::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t AccessTracker::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void AccessTracker::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t AccessTracker::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t AccessTracker::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t AccessTracker::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void AccessTracker::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t AccessTracker::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t AccessTracker::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t AccessTracker::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        AccessTracker,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>,
        ::std::map<::std::int64_t, ::facebook::cachelib::navy::serialization::AccessStats>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        AccessTracker,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<::facebook::cachelib::navy::serialization::AccessStatsPair>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        AccessTracker,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>,
        ::std::map<::std::int64_t, ::facebook::cachelib::navy::serialization::AccessStats>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        AccessTracker,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<::facebook::cachelib::navy::serialization::AccessStatsPair>>,
    "inconsistent use of nimble option");

}}}} // facebook::cachelib::navy::serialization

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::cachelib::navy::serialization::BlockCacheConfig>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::facebook::cachelib::navy::serialization::BlockCacheConfig>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace cachelib { namespace navy { namespace serialization {

BlockCacheConfig::BlockCacheConfig(const BlockCacheConfig&) = default;
BlockCacheConfig& BlockCacheConfig::operator=(const BlockCacheConfig&) = default;
BlockCacheConfig::BlockCacheConfig() :
      version(static_cast<::std::int64_t>(0)),
      cacheBaseOffset(static_cast<::std::int64_t>(0)),
      cacheSize(static_cast<::std::int64_t>(0)),
      allocAlignSize(static_cast<::std::int32_t>(0)),
      checksum(static_cast<bool>(false)),
      __fbthrift_field_holeCount(static_cast<::std::int64_t>(0)),
      __fbthrift_field_holeSizeTotal(static_cast<::std::int64_t>(0)),
      __fbthrift_field_reinsertionPolicyEnabled(static_cast<bool>(false)) {
}


BlockCacheConfig::~BlockCacheConfig() {}

BlockCacheConfig::BlockCacheConfig(BlockCacheConfig&& other) noexcept  :
    version(std::move(other.version)),
    cacheBaseOffset(std::move(other.cacheBaseOffset)),
    cacheSize(std::move(other.cacheSize)),
    allocAlignSize(std::move(other.allocAlignSize)),
    sizeClasses(std::move(other.sizeClasses)),
    checksum(std::move(other.checksum)),
    __fbthrift_field_sizeDist(std::move(other.__fbthrift_field_sizeDist)),
    __fbthrift_field_holeCount(std::move(other.__fbthrift_field_holeCount)),
    __fbthrift_field_holeSizeTotal(std::move(other.__fbthrift_field_holeSizeTotal)),
    __fbthrift_field_reinsertionPolicyEnabled(std::move(other.__fbthrift_field_reinsertionPolicyEnabled)),
    __isset(other.__isset) {
}

BlockCacheConfig& BlockCacheConfig::operator=(FOLLY_MAYBE_UNUSED BlockCacheConfig&& other) noexcept {
    this->version = std::move(other.version);
    this->cacheBaseOffset = std::move(other.cacheBaseOffset);
    this->cacheSize = std::move(other.cacheSize);
    this->allocAlignSize = std::move(other.allocAlignSize);
    this->sizeClasses = std::move(other.sizeClasses);
    this->checksum = std::move(other.checksum);
    this->__fbthrift_field_sizeDist = std::move(other.__fbthrift_field_sizeDist);
    this->__fbthrift_field_holeCount = std::move(other.__fbthrift_field_holeCount);
    this->__fbthrift_field_holeSizeTotal = std::move(other.__fbthrift_field_holeSizeTotal);
    this->__fbthrift_field_reinsertionPolicyEnabled = std::move(other.__fbthrift_field_reinsertionPolicyEnabled);
    __isset = other.__isset;
    return *this;
}


BlockCacheConfig::BlockCacheConfig(apache::thrift::FragileConstructor, ::std::int64_t version__arg, ::std::int64_t cacheBaseOffset__arg, ::std::int64_t cacheSize__arg, ::std::int32_t allocAlignSize__arg, ::std::set<::std::int32_t> sizeClasses__arg, bool checksum__arg, ::std::map<::std::int64_t, ::std::int64_t> sizeDist__arg, ::std::int64_t holeCount__arg, ::std::int64_t holeSizeTotal__arg, bool reinsertionPolicyEnabled__arg) :
    version(std::move(version__arg)),
    cacheBaseOffset(std::move(cacheBaseOffset__arg)),
    cacheSize(std::move(cacheSize__arg)),
    allocAlignSize(std::move(allocAlignSize__arg)),
    sizeClasses(std::move(sizeClasses__arg)),
    checksum(std::move(checksum__arg)),
    __fbthrift_field_sizeDist(std::move(sizeDist__arg)),
    __fbthrift_field_holeCount(std::move(holeCount__arg)),
    __fbthrift_field_holeSizeTotal(std::move(holeSizeTotal__arg)),
    __fbthrift_field_reinsertionPolicyEnabled(std::move(reinsertionPolicyEnabled__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
  __isset.set(folly::index_constant<3>(), true);
}


void BlockCacheConfig::__clear() {
  // clear all fields
  this->version = static_cast<::std::int64_t>(0);
  this->cacheBaseOffset = static_cast<::std::int64_t>(0);
  this->cacheSize = static_cast<::std::int64_t>(0);
  this->allocAlignSize = static_cast<::std::int32_t>(0);
  this->sizeClasses.clear();
  this->checksum = static_cast<bool>(false);
  this->__fbthrift_field_sizeDist.clear();
  this->__fbthrift_field_holeCount = static_cast<::std::int64_t>(0);
  this->__fbthrift_field_holeSizeTotal = static_cast<::std::int64_t>(0);
  this->__fbthrift_field_reinsertionPolicyEnabled = static_cast<bool>(false);
  __isset = {};
}

bool BlockCacheConfig::operator==(const BlockCacheConfig& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.version_ref() == rhs.version_ref())) {
    return false;
  }
  if (!(lhs.cacheBaseOffset_ref() == rhs.cacheBaseOffset_ref())) {
    return false;
  }
  if (!(lhs.cacheSize_ref() == rhs.cacheSize_ref())) {
    return false;
  }
  if (!(lhs.allocAlignSize_ref() == rhs.allocAlignSize_ref())) {
    return false;
  }
  if (!(lhs.sizeClasses_ref() == rhs.sizeClasses_ref())) {
    return false;
  }
  if (!(lhs.checksum_ref() == rhs.checksum_ref())) {
    return false;
  }
  if (!(lhs.sizeDist_ref() == rhs.sizeDist_ref())) {
    return false;
  }
  if (!(lhs.holeCount_ref() == rhs.holeCount_ref())) {
    return false;
  }
  if (!(lhs.holeSizeTotal_ref() == rhs.holeSizeTotal_ref())) {
    return false;
  }
  if (!(lhs.reinsertionPolicyEnabled_ref() == rhs.reinsertionPolicyEnabled_ref())) {
    return false;
  }
  return true;
}

bool BlockCacheConfig::operator<(const BlockCacheConfig& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.version_ref() == rhs.version_ref())) {
    return lhs.version_ref() < rhs.version_ref();
  }
  if (!(lhs.cacheBaseOffset_ref() == rhs.cacheBaseOffset_ref())) {
    return lhs.cacheBaseOffset_ref() < rhs.cacheBaseOffset_ref();
  }
  if (!(lhs.cacheSize_ref() == rhs.cacheSize_ref())) {
    return lhs.cacheSize_ref() < rhs.cacheSize_ref();
  }
  if (!(lhs.allocAlignSize_ref() == rhs.allocAlignSize_ref())) {
    return lhs.allocAlignSize_ref() < rhs.allocAlignSize_ref();
  }
  if (!(lhs.sizeClasses_ref() == rhs.sizeClasses_ref())) {
    return lhs.sizeClasses_ref() < rhs.sizeClasses_ref();
  }
  if (!(lhs.checksum_ref() == rhs.checksum_ref())) {
    return lhs.checksum_ref() < rhs.checksum_ref();
  }
  if (!(lhs.sizeDist_ref() == rhs.sizeDist_ref())) {
    return lhs.sizeDist_ref() < rhs.sizeDist_ref();
  }
  if (!(lhs.holeCount_ref() == rhs.holeCount_ref())) {
    return lhs.holeCount_ref() < rhs.holeCount_ref();
  }
  if (!(lhs.holeSizeTotal_ref() == rhs.holeSizeTotal_ref())) {
    return lhs.holeSizeTotal_ref() < rhs.holeSizeTotal_ref();
  }
  if (!(lhs.reinsertionPolicyEnabled_ref() == rhs.reinsertionPolicyEnabled_ref())) {
    return lhs.reinsertionPolicyEnabled_ref() < rhs.reinsertionPolicyEnabled_ref();
  }
  return false;
}

const ::std::set<::std::int32_t>& BlockCacheConfig::get_sizeClasses() const& {
  return sizeClasses;
}

::std::set<::std::int32_t> BlockCacheConfig::get_sizeClasses() && {
  return std::move(sizeClasses);
}

const ::std::map<::std::int64_t, ::std::int64_t>& BlockCacheConfig::get_sizeDist() const& {
  return __fbthrift_field_sizeDist;
}

::std::map<::std::int64_t, ::std::int64_t> BlockCacheConfig::get_sizeDist() && {
  return std::move(__fbthrift_field_sizeDist);
}


void swap(BlockCacheConfig& a, BlockCacheConfig& b) {
  using ::std::swap;
  swap(a.version_ref().value(), b.version_ref().value());
  swap(a.cacheBaseOffset_ref().value(), b.cacheBaseOffset_ref().value());
  swap(a.cacheSize_ref().value(), b.cacheSize_ref().value());
  swap(a.allocAlignSize_ref().value(), b.allocAlignSize_ref().value());
  swap(a.sizeClasses_ref().value(), b.sizeClasses_ref().value());
  swap(a.checksum_ref().value(), b.checksum_ref().value());
  swap(a.sizeDist_ref().value(), b.sizeDist_ref().value());
  swap(a.holeCount_ref().value(), b.holeCount_ref().value());
  swap(a.holeSizeTotal_ref().value(), b.holeSizeTotal_ref().value());
  swap(a.reinsertionPolicyEnabled_ref().value(), b.reinsertionPolicyEnabled_ref().value());
  swap(a.__isset, b.__isset);
}

template void BlockCacheConfig::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t BlockCacheConfig::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t BlockCacheConfig::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t BlockCacheConfig::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void BlockCacheConfig::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t BlockCacheConfig::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t BlockCacheConfig::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t BlockCacheConfig::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void BlockCacheConfig::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t BlockCacheConfig::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t BlockCacheConfig::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t BlockCacheConfig::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;



}}}} // facebook::cachelib::navy::serialization

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::cachelib::navy::serialization::BigHashPersistentData>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::facebook::cachelib::navy::serialization::BigHashPersistentData>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace cachelib { namespace navy { namespace serialization {

BigHashPersistentData::BigHashPersistentData(const BigHashPersistentData&) = default;
BigHashPersistentData& BigHashPersistentData::operator=(const BigHashPersistentData&) = default;
BigHashPersistentData::BigHashPersistentData() :
      version(static_cast<::std::int32_t>(0)),
      generationTime(static_cast<::std::int64_t>(0)),
      itemCount(static_cast<::std::int64_t>(0)),
      bucketSize(static_cast<::std::int64_t>(0)),
      cacheBaseOffset(static_cast<::std::int64_t>(0)),
      numBuckets(static_cast<::std::int64_t>(0)) {
}


BigHashPersistentData::~BigHashPersistentData() {}

BigHashPersistentData::BigHashPersistentData(BigHashPersistentData&& other) noexcept  :
    version(std::move(other.version)),
    generationTime(std::move(other.generationTime)),
    itemCount(std::move(other.itemCount)),
    bucketSize(std::move(other.bucketSize)),
    cacheBaseOffset(std::move(other.cacheBaseOffset)),
    numBuckets(std::move(other.numBuckets)),
    __fbthrift_field_sizeDist(std::move(other.__fbthrift_field_sizeDist)),
    __isset(other.__isset) {
}

BigHashPersistentData& BigHashPersistentData::operator=(FOLLY_MAYBE_UNUSED BigHashPersistentData&& other) noexcept {
    this->version = std::move(other.version);
    this->generationTime = std::move(other.generationTime);
    this->itemCount = std::move(other.itemCount);
    this->bucketSize = std::move(other.bucketSize);
    this->cacheBaseOffset = std::move(other.cacheBaseOffset);
    this->numBuckets = std::move(other.numBuckets);
    this->__fbthrift_field_sizeDist = std::move(other.__fbthrift_field_sizeDist);
    __isset = other.__isset;
    return *this;
}


BigHashPersistentData::BigHashPersistentData(apache::thrift::FragileConstructor, ::std::int32_t version__arg, ::std::int64_t generationTime__arg, ::std::int64_t itemCount__arg, ::std::int64_t bucketSize__arg, ::std::int64_t cacheBaseOffset__arg, ::std::int64_t numBuckets__arg, ::std::map<::std::int64_t, ::std::int64_t> sizeDist__arg) :
    version(std::move(version__arg)),
    generationTime(std::move(generationTime__arg)),
    itemCount(std::move(itemCount__arg)),
    bucketSize(std::move(bucketSize__arg)),
    cacheBaseOffset(std::move(cacheBaseOffset__arg)),
    numBuckets(std::move(numBuckets__arg)),
    __fbthrift_field_sizeDist(std::move(sizeDist__arg)) {
  __isset.set(folly::index_constant<0>(), true);
}


void BigHashPersistentData::__clear() {
  // clear all fields
  this->version = static_cast<::std::int32_t>(0);
  this->generationTime = static_cast<::std::int64_t>(0);
  this->itemCount = static_cast<::std::int64_t>(0);
  this->bucketSize = static_cast<::std::int64_t>(0);
  this->cacheBaseOffset = static_cast<::std::int64_t>(0);
  this->numBuckets = static_cast<::std::int64_t>(0);
  this->__fbthrift_field_sizeDist.clear();
  __isset = {};
}

bool BigHashPersistentData::operator==(const BigHashPersistentData& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.version_ref() == rhs.version_ref())) {
    return false;
  }
  if (!(lhs.generationTime_ref() == rhs.generationTime_ref())) {
    return false;
  }
  if (!(lhs.itemCount_ref() == rhs.itemCount_ref())) {
    return false;
  }
  if (!(lhs.bucketSize_ref() == rhs.bucketSize_ref())) {
    return false;
  }
  if (!(lhs.cacheBaseOffset_ref() == rhs.cacheBaseOffset_ref())) {
    return false;
  }
  if (!(lhs.numBuckets_ref() == rhs.numBuckets_ref())) {
    return false;
  }
  if (!(lhs.sizeDist_ref() == rhs.sizeDist_ref())) {
    return false;
  }
  return true;
}

bool BigHashPersistentData::operator<(const BigHashPersistentData& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.version_ref() == rhs.version_ref())) {
    return lhs.version_ref() < rhs.version_ref();
  }
  if (!(lhs.generationTime_ref() == rhs.generationTime_ref())) {
    return lhs.generationTime_ref() < rhs.generationTime_ref();
  }
  if (!(lhs.itemCount_ref() == rhs.itemCount_ref())) {
    return lhs.itemCount_ref() < rhs.itemCount_ref();
  }
  if (!(lhs.bucketSize_ref() == rhs.bucketSize_ref())) {
    return lhs.bucketSize_ref() < rhs.bucketSize_ref();
  }
  if (!(lhs.cacheBaseOffset_ref() == rhs.cacheBaseOffset_ref())) {
    return lhs.cacheBaseOffset_ref() < rhs.cacheBaseOffset_ref();
  }
  if (!(lhs.numBuckets_ref() == rhs.numBuckets_ref())) {
    return lhs.numBuckets_ref() < rhs.numBuckets_ref();
  }
  if (!(lhs.sizeDist_ref() == rhs.sizeDist_ref())) {
    return lhs.sizeDist_ref() < rhs.sizeDist_ref();
  }
  return false;
}

const ::std::map<::std::int64_t, ::std::int64_t>& BigHashPersistentData::get_sizeDist() const& {
  return __fbthrift_field_sizeDist;
}

::std::map<::std::int64_t, ::std::int64_t> BigHashPersistentData::get_sizeDist() && {
  return std::move(__fbthrift_field_sizeDist);
}


void swap(BigHashPersistentData& a, BigHashPersistentData& b) {
  using ::std::swap;
  swap(a.version_ref().value(), b.version_ref().value());
  swap(a.generationTime_ref().value(), b.generationTime_ref().value());
  swap(a.itemCount_ref().value(), b.itemCount_ref().value());
  swap(a.bucketSize_ref().value(), b.bucketSize_ref().value());
  swap(a.cacheBaseOffset_ref().value(), b.cacheBaseOffset_ref().value());
  swap(a.numBuckets_ref().value(), b.numBuckets_ref().value());
  swap(a.sizeDist_ref().value(), b.sizeDist_ref().value());
  swap(a.__isset, b.__isset);
}

template void BigHashPersistentData::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t BigHashPersistentData::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t BigHashPersistentData::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t BigHashPersistentData::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void BigHashPersistentData::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t BigHashPersistentData::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t BigHashPersistentData::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t BigHashPersistentData::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;
template void BigHashPersistentData::readNoXfer<>(apache::thrift::SimpleJSONProtocolReader*);
template uint32_t BigHashPersistentData::write<>(apache::thrift::SimpleJSONProtocolWriter*) const;
template uint32_t BigHashPersistentData::serializedSize<>(apache::thrift::SimpleJSONProtocolWriter const*) const;
template uint32_t BigHashPersistentData::serializedSizeZC<>(apache::thrift::SimpleJSONProtocolWriter const*) const;



}}}} // facebook::cachelib::navy::serialization

namespace facebook { namespace cachelib { namespace navy { namespace serialization { namespace {
FOLLY_MAYBE_UNUSED FOLLY_ERASE void validateAdapters() {
}
}}}}} // facebook::cachelib::navy::serialization
