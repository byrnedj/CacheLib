/**
 * Autogenerated by Thrift for objects.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */
#include "objects_types.h"
#include "objects_types.tcc"

#include <thrift/lib/cpp2/gen/module_types_cpp.h>

#include "objects_data.h"


namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::cachelib::serialization::SlabAllocatorObject>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::facebook::cachelib::serialization::SlabAllocatorObject>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace cachelib { namespace serialization {

SlabAllocatorObject::SlabAllocatorObject(const SlabAllocatorObject&) = default;
SlabAllocatorObject& SlabAllocatorObject::operator=(const SlabAllocatorObject&) = default;
SlabAllocatorObject::SlabAllocatorObject() :
      memorySize(),
      canAllocate(),
      slabSize(),
      minAllocSize(),
      nextSlabIdx() {
}


SlabAllocatorObject::~SlabAllocatorObject() {}

SlabAllocatorObject::SlabAllocatorObject(SlabAllocatorObject&& other) noexcept  :
    memorySize(std::move(other.memorySize)),
    canAllocate(std::move(other.canAllocate)),
    memoryPoolSize(std::move(other.memoryPoolSize)),
    slabSize(std::move(other.slabSize)),
    minAllocSize(std::move(other.minAllocSize)),
    nextSlabIdx(std::move(other.nextSlabIdx)),
    freeSlabIdxs(std::move(other.freeSlabIdxs)),
    __fbthrift_field_advisedSlabIdxs(std::move(other.__fbthrift_field_advisedSlabIdxs)),
    __isset(other.__isset) {
}

SlabAllocatorObject& SlabAllocatorObject::operator=(FOLLY_MAYBE_UNUSED SlabAllocatorObject&& other) noexcept {
    this->memorySize = std::move(other.memorySize);
    this->canAllocate = std::move(other.canAllocate);
    this->memoryPoolSize = std::move(other.memoryPoolSize);
    this->slabSize = std::move(other.slabSize);
    this->minAllocSize = std::move(other.minAllocSize);
    this->nextSlabIdx = std::move(other.nextSlabIdx);
    this->freeSlabIdxs = std::move(other.freeSlabIdxs);
    this->__fbthrift_field_advisedSlabIdxs = std::move(other.__fbthrift_field_advisedSlabIdxs);
    __isset = other.__isset;
    return *this;
}


SlabAllocatorObject::SlabAllocatorObject(apache::thrift::FragileConstructor, ::std::int64_t memorySize__arg, bool canAllocate__arg, ::std::map<::std::int8_t, ::std::int64_t> memoryPoolSize__arg, ::std::int64_t slabSize__arg, ::std::int64_t minAllocSize__arg, ::std::int32_t nextSlabIdx__arg, ::std::vector<::std::int32_t> freeSlabIdxs__arg, ::std::vector<::std::int32_t> advisedSlabIdxs__arg) :
    memorySize(std::move(memorySize__arg)),
    canAllocate(std::move(canAllocate__arg)),
    memoryPoolSize(std::move(memoryPoolSize__arg)),
    slabSize(std::move(slabSize__arg)),
    minAllocSize(std::move(minAllocSize__arg)),
    nextSlabIdx(std::move(nextSlabIdx__arg)),
    freeSlabIdxs(std::move(freeSlabIdxs__arg)),
    __fbthrift_field_advisedSlabIdxs(std::move(advisedSlabIdxs__arg)) {
  __isset.set(folly::index_constant<0>(), true);
}


void SlabAllocatorObject::__clear() {
  // clear all fields
  this->memorySize = ::std::int64_t();
  this->canAllocate = bool();
  this->memoryPoolSize.clear();
  this->slabSize = ::std::int64_t();
  this->minAllocSize = ::std::int64_t();
  this->nextSlabIdx = ::std::int32_t();
  this->freeSlabIdxs.clear();
  this->__fbthrift_field_advisedSlabIdxs.clear();
  __isset = {};
}

bool SlabAllocatorObject::operator==(const SlabAllocatorObject& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.memorySize_ref() == rhs.memorySize_ref())) {
    return false;
  }
  if (!(lhs.canAllocate_ref() == rhs.canAllocate_ref())) {
    return false;
  }
  if (!(lhs.memoryPoolSize_ref() == rhs.memoryPoolSize_ref())) {
    return false;
  }
  if (!(lhs.slabSize_ref() == rhs.slabSize_ref())) {
    return false;
  }
  if (!(lhs.minAllocSize_ref() == rhs.minAllocSize_ref())) {
    return false;
  }
  if (!(lhs.nextSlabIdx_ref() == rhs.nextSlabIdx_ref())) {
    return false;
  }
  if (!(lhs.freeSlabIdxs_ref() == rhs.freeSlabIdxs_ref())) {
    return false;
  }
  if (!(lhs.advisedSlabIdxs_ref() == rhs.advisedSlabIdxs_ref())) {
    return false;
  }
  return true;
}

bool SlabAllocatorObject::operator<(const SlabAllocatorObject& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.memorySize_ref() == rhs.memorySize_ref())) {
    return lhs.memorySize_ref() < rhs.memorySize_ref();
  }
  if (!(lhs.canAllocate_ref() == rhs.canAllocate_ref())) {
    return lhs.canAllocate_ref() < rhs.canAllocate_ref();
  }
  if (!(lhs.memoryPoolSize_ref() == rhs.memoryPoolSize_ref())) {
    return lhs.memoryPoolSize_ref() < rhs.memoryPoolSize_ref();
  }
  if (!(lhs.slabSize_ref() == rhs.slabSize_ref())) {
    return lhs.slabSize_ref() < rhs.slabSize_ref();
  }
  if (!(lhs.minAllocSize_ref() == rhs.minAllocSize_ref())) {
    return lhs.minAllocSize_ref() < rhs.minAllocSize_ref();
  }
  if (!(lhs.nextSlabIdx_ref() == rhs.nextSlabIdx_ref())) {
    return lhs.nextSlabIdx_ref() < rhs.nextSlabIdx_ref();
  }
  if (!(lhs.freeSlabIdxs_ref() == rhs.freeSlabIdxs_ref())) {
    return lhs.freeSlabIdxs_ref() < rhs.freeSlabIdxs_ref();
  }
  if (!(lhs.advisedSlabIdxs_ref() == rhs.advisedSlabIdxs_ref())) {
    return lhs.advisedSlabIdxs_ref() < rhs.advisedSlabIdxs_ref();
  }
  return false;
}

const ::std::map<::std::int8_t, ::std::int64_t>& SlabAllocatorObject::get_memoryPoolSize() const& {
  return memoryPoolSize;
}

::std::map<::std::int8_t, ::std::int64_t> SlabAllocatorObject::get_memoryPoolSize() && {
  return std::move(memoryPoolSize);
}

const ::std::vector<::std::int32_t>& SlabAllocatorObject::get_freeSlabIdxs() const& {
  return freeSlabIdxs;
}

::std::vector<::std::int32_t> SlabAllocatorObject::get_freeSlabIdxs() && {
  return std::move(freeSlabIdxs);
}

const ::std::vector<::std::int32_t>& SlabAllocatorObject::get_advisedSlabIdxs() const& {
  return __fbthrift_field_advisedSlabIdxs;
}

::std::vector<::std::int32_t> SlabAllocatorObject::get_advisedSlabIdxs() && {
  return std::move(__fbthrift_field_advisedSlabIdxs);
}


void swap(SlabAllocatorObject& a, SlabAllocatorObject& b) {
  using ::std::swap;
  swap(a.memorySize_ref().value(), b.memorySize_ref().value());
  swap(a.canAllocate_ref().value(), b.canAllocate_ref().value());
  swap(a.memoryPoolSize_ref().value(), b.memoryPoolSize_ref().value());
  swap(a.slabSize_ref().value(), b.slabSize_ref().value());
  swap(a.minAllocSize_ref().value(), b.minAllocSize_ref().value());
  swap(a.nextSlabIdx_ref().value(), b.nextSlabIdx_ref().value());
  swap(a.freeSlabIdxs_ref().value(), b.freeSlabIdxs_ref().value());
  swap(a.advisedSlabIdxs_ref().value(), b.advisedSlabIdxs_ref().value());
  swap(a.__isset, b.__isset);
}

template void SlabAllocatorObject::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t SlabAllocatorObject::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t SlabAllocatorObject::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t SlabAllocatorObject::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void SlabAllocatorObject::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t SlabAllocatorObject::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t SlabAllocatorObject::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t SlabAllocatorObject::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::cachelib::serialization

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::cachelib::serialization::AllocationClassObject>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::facebook::cachelib::serialization::AllocationClassObject>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace cachelib { namespace serialization {

AllocationClassObject::AllocationClassObject(const AllocationClassObject&) = default;
AllocationClassObject& AllocationClassObject::operator=(const AllocationClassObject&) = default;
AllocationClassObject::AllocationClassObject() :
      classId(),
      allocationSize(),
      currOffset(),
      canAllocate(),
      currSlabIdx() {
}


AllocationClassObject::~AllocationClassObject() {}

AllocationClassObject::AllocationClassObject(AllocationClassObject&& other) noexcept  :
    classId(std::move(other.classId)),
    allocationSize(std::move(other.allocationSize)),
    currOffset(std::move(other.currOffset)),
    canAllocate(std::move(other.canAllocate)),
    __fbthrift_field_freedAllocationsObject(std::move(other.__fbthrift_field_freedAllocationsObject)),
    currSlabIdx(std::move(other.currSlabIdx)),
    allocatedSlabIdxs(std::move(other.allocatedSlabIdxs)),
    freeSlabIdxs(std::move(other.freeSlabIdxs)),
    __isset(other.__isset) {
}

AllocationClassObject& AllocationClassObject::operator=(FOLLY_MAYBE_UNUSED AllocationClassObject&& other) noexcept {
    this->classId = std::move(other.classId);
    this->allocationSize = std::move(other.allocationSize);
    this->currOffset = std::move(other.currOffset);
    this->canAllocate = std::move(other.canAllocate);
    this->__fbthrift_field_freedAllocationsObject = std::move(other.__fbthrift_field_freedAllocationsObject);
    this->currSlabIdx = std::move(other.currSlabIdx);
    this->allocatedSlabIdxs = std::move(other.allocatedSlabIdxs);
    this->freeSlabIdxs = std::move(other.freeSlabIdxs);
    __isset = other.__isset;
    return *this;
}


AllocationClassObject::AllocationClassObject(apache::thrift::FragileConstructor, ::std::int8_t classId__arg, ::std::int64_t allocationSize__arg, ::std::int64_t currOffset__arg, bool canAllocate__arg, ::facebook::cachelib::serialization::SListObject freedAllocationsObject__arg, ::std::int32_t currSlabIdx__arg, ::std::vector<::std::int32_t> allocatedSlabIdxs__arg, ::std::vector<::std::int32_t> freeSlabIdxs__arg) :
    classId(std::move(classId__arg)),
    allocationSize(std::move(allocationSize__arg)),
    currOffset(std::move(currOffset__arg)),
    canAllocate(std::move(canAllocate__arg)),
    __fbthrift_field_freedAllocationsObject(std::move(freedAllocationsObject__arg)),
    currSlabIdx(std::move(currSlabIdx__arg)),
    allocatedSlabIdxs(std::move(allocatedSlabIdxs__arg)),
    freeSlabIdxs(std::move(freeSlabIdxs__arg)) {
  __isset.set(folly::index_constant<0>(), true);
}


void AllocationClassObject::__clear() {
  // clear all fields
  this->classId = ::std::int8_t();
  this->allocationSize = ::std::int64_t();
  this->currOffset = ::std::int64_t();
  this->canAllocate = bool();
  this->__fbthrift_field_freedAllocationsObject.__clear();
  this->currSlabIdx = ::std::int32_t();
  this->allocatedSlabIdxs.clear();
  this->freeSlabIdxs.clear();
  __isset = {};
}

bool AllocationClassObject::operator==(const AllocationClassObject& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.classId_ref() == rhs.classId_ref())) {
    return false;
  }
  if (!(lhs.allocationSize_ref() == rhs.allocationSize_ref())) {
    return false;
  }
  if (!(lhs.currOffset_ref() == rhs.currOffset_ref())) {
    return false;
  }
  if (!(lhs.canAllocate_ref() == rhs.canAllocate_ref())) {
    return false;
  }
  if (!(lhs.freedAllocationsObject_ref() == rhs.freedAllocationsObject_ref())) {
    return false;
  }
  if (!(lhs.currSlabIdx_ref() == rhs.currSlabIdx_ref())) {
    return false;
  }
  if (!(lhs.allocatedSlabIdxs_ref() == rhs.allocatedSlabIdxs_ref())) {
    return false;
  }
  if (!(lhs.freeSlabIdxs_ref() == rhs.freeSlabIdxs_ref())) {
    return false;
  }
  return true;
}

bool AllocationClassObject::operator<(const AllocationClassObject& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.classId_ref() == rhs.classId_ref())) {
    return lhs.classId_ref() < rhs.classId_ref();
  }
  if (!(lhs.allocationSize_ref() == rhs.allocationSize_ref())) {
    return lhs.allocationSize_ref() < rhs.allocationSize_ref();
  }
  if (!(lhs.currOffset_ref() == rhs.currOffset_ref())) {
    return lhs.currOffset_ref() < rhs.currOffset_ref();
  }
  if (!(lhs.canAllocate_ref() == rhs.canAllocate_ref())) {
    return lhs.canAllocate_ref() < rhs.canAllocate_ref();
  }
  if (!(lhs.freedAllocationsObject_ref() == rhs.freedAllocationsObject_ref())) {
    return lhs.freedAllocationsObject_ref() < rhs.freedAllocationsObject_ref();
  }
  if (!(lhs.currSlabIdx_ref() == rhs.currSlabIdx_ref())) {
    return lhs.currSlabIdx_ref() < rhs.currSlabIdx_ref();
  }
  if (!(lhs.allocatedSlabIdxs_ref() == rhs.allocatedSlabIdxs_ref())) {
    return lhs.allocatedSlabIdxs_ref() < rhs.allocatedSlabIdxs_ref();
  }
  if (!(lhs.freeSlabIdxs_ref() == rhs.freeSlabIdxs_ref())) {
    return lhs.freeSlabIdxs_ref() < rhs.freeSlabIdxs_ref();
  }
  return false;
}

const ::facebook::cachelib::serialization::SListObject& AllocationClassObject::get_freedAllocationsObject() const& {
  return __fbthrift_field_freedAllocationsObject;
}

::facebook::cachelib::serialization::SListObject AllocationClassObject::get_freedAllocationsObject() && {
  return std::move(__fbthrift_field_freedAllocationsObject);
}

const ::std::vector<::std::int32_t>& AllocationClassObject::get_allocatedSlabIdxs() const& {
  return allocatedSlabIdxs;
}

::std::vector<::std::int32_t> AllocationClassObject::get_allocatedSlabIdxs() && {
  return std::move(allocatedSlabIdxs);
}

const ::std::vector<::std::int32_t>& AllocationClassObject::get_freeSlabIdxs() const& {
  return freeSlabIdxs;
}

::std::vector<::std::int32_t> AllocationClassObject::get_freeSlabIdxs() && {
  return std::move(freeSlabIdxs);
}


void swap(AllocationClassObject& a, AllocationClassObject& b) {
  using ::std::swap;
  swap(a.classId_ref().value(), b.classId_ref().value());
  swap(a.allocationSize_ref().value(), b.allocationSize_ref().value());
  swap(a.currOffset_ref().value(), b.currOffset_ref().value());
  swap(a.canAllocate_ref().value(), b.canAllocate_ref().value());
  swap(a.freedAllocationsObject_ref().value(), b.freedAllocationsObject_ref().value());
  swap(a.currSlabIdx_ref().value(), b.currSlabIdx_ref().value());
  swap(a.allocatedSlabIdxs_ref().value(), b.allocatedSlabIdxs_ref().value());
  swap(a.freeSlabIdxs_ref().value(), b.freeSlabIdxs_ref().value());
  swap(a.__isset, b.__isset);
}

template void AllocationClassObject::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t AllocationClassObject::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t AllocationClassObject::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t AllocationClassObject::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void AllocationClassObject::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t AllocationClassObject::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t AllocationClassObject::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t AllocationClassObject::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        AllocationClassObject,
        ::apache::thrift::type_class::structure,
        ::facebook::cachelib::serialization::SListObject>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        AllocationClassObject,
        ::apache::thrift::type_class::structure,
        ::facebook::cachelib::serialization::SListObject>,
    "inconsistent use of nimble option");

}}} // facebook::cachelib::serialization

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::cachelib::serialization::MemoryPoolObject>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::facebook::cachelib::serialization::MemoryPoolObject>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace cachelib { namespace serialization {

MemoryPoolObject::MemoryPoolObject(const MemoryPoolObject&) = default;
MemoryPoolObject& MemoryPoolObject::operator=(const MemoryPoolObject&) = default;
MemoryPoolObject::MemoryPoolObject() :
      id(),
      maxSize(),
      currSlabAllocSize(),
      currAllocSize(),
      __fbthrift_field_numSlabResize(static_cast<::std::int64_t>(0)),
      __fbthrift_field_numSlabRebalance(static_cast<::std::int64_t>(0)),
      __fbthrift_field_numSlabsAdvised(static_cast<::std::int64_t>(0)) {
}


MemoryPoolObject::~MemoryPoolObject() {}

MemoryPoolObject::MemoryPoolObject(MemoryPoolObject&& other) noexcept  :
    id(std::move(other.id)),
    maxSize(std::move(other.maxSize)),
    currSlabAllocSize(std::move(other.currSlabAllocSize)),
    currAllocSize(std::move(other.currAllocSize)),
    acSizes(std::move(other.acSizes)),
    ac(std::move(other.ac)),
    __fbthrift_field_numSlabResize(std::move(other.__fbthrift_field_numSlabResize)),
    __fbthrift_field_numSlabRebalance(std::move(other.__fbthrift_field_numSlabRebalance)),
    freeSlabIdxs(std::move(other.freeSlabIdxs)),
    __fbthrift_field_numSlabsAdvised(std::move(other.__fbthrift_field_numSlabsAdvised)),
    __isset(other.__isset) {
}

MemoryPoolObject& MemoryPoolObject::operator=(FOLLY_MAYBE_UNUSED MemoryPoolObject&& other) noexcept {
    this->id = std::move(other.id);
    this->maxSize = std::move(other.maxSize);
    this->currSlabAllocSize = std::move(other.currSlabAllocSize);
    this->currAllocSize = std::move(other.currAllocSize);
    this->acSizes = std::move(other.acSizes);
    this->ac = std::move(other.ac);
    this->__fbthrift_field_numSlabResize = std::move(other.__fbthrift_field_numSlabResize);
    this->__fbthrift_field_numSlabRebalance = std::move(other.__fbthrift_field_numSlabRebalance);
    this->freeSlabIdxs = std::move(other.freeSlabIdxs);
    this->__fbthrift_field_numSlabsAdvised = std::move(other.__fbthrift_field_numSlabsAdvised);
    __isset = other.__isset;
    return *this;
}


MemoryPoolObject::MemoryPoolObject(apache::thrift::FragileConstructor, ::std::int8_t id__arg, ::std::int64_t maxSize__arg, ::std::int64_t currSlabAllocSize__arg, ::std::int64_t currAllocSize__arg, ::std::vector<::std::int64_t> acSizes__arg, ::std::vector<::facebook::cachelib::serialization::AllocationClassObject> ac__arg, ::std::int64_t numSlabResize__arg, ::std::int64_t numSlabRebalance__arg, ::std::vector<::std::int32_t> freeSlabIdxs__arg, ::std::int64_t numSlabsAdvised__arg) :
    id(std::move(id__arg)),
    maxSize(std::move(maxSize__arg)),
    currSlabAllocSize(std::move(currSlabAllocSize__arg)),
    currAllocSize(std::move(currAllocSize__arg)),
    acSizes(std::move(acSizes__arg)),
    ac(std::move(ac__arg)),
    __fbthrift_field_numSlabResize(std::move(numSlabResize__arg)),
    __fbthrift_field_numSlabRebalance(std::move(numSlabRebalance__arg)),
    freeSlabIdxs(std::move(freeSlabIdxs__arg)),
    __fbthrift_field_numSlabsAdvised(std::move(numSlabsAdvised__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
}


void MemoryPoolObject::__clear() {
  // clear all fields
  this->id = ::std::int8_t();
  this->maxSize = ::std::int64_t();
  this->currSlabAllocSize = ::std::int64_t();
  this->currAllocSize = ::std::int64_t();
  this->acSizes.clear();
  this->ac.clear();
  this->__fbthrift_field_numSlabResize = static_cast<::std::int64_t>(0);
  this->__fbthrift_field_numSlabRebalance = static_cast<::std::int64_t>(0);
  this->freeSlabIdxs.clear();
  this->__fbthrift_field_numSlabsAdvised = static_cast<::std::int64_t>(0);
  __isset = {};
}

bool MemoryPoolObject::operator==(const MemoryPoolObject& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.id_ref() == rhs.id_ref())) {
    return false;
  }
  if (!(lhs.maxSize_ref() == rhs.maxSize_ref())) {
    return false;
  }
  if (!(lhs.currSlabAllocSize_ref() == rhs.currSlabAllocSize_ref())) {
    return false;
  }
  if (!(lhs.currAllocSize_ref() == rhs.currAllocSize_ref())) {
    return false;
  }
  if (!(lhs.acSizes_ref() == rhs.acSizes_ref())) {
    return false;
  }
  if (!(lhs.ac_ref() == rhs.ac_ref())) {
    return false;
  }
  if (!(lhs.numSlabResize_ref() == rhs.numSlabResize_ref())) {
    return false;
  }
  if (!(lhs.numSlabRebalance_ref() == rhs.numSlabRebalance_ref())) {
    return false;
  }
  if (!(lhs.freeSlabIdxs_ref() == rhs.freeSlabIdxs_ref())) {
    return false;
  }
  if (!(lhs.numSlabsAdvised_ref() == rhs.numSlabsAdvised_ref())) {
    return false;
  }
  return true;
}

bool MemoryPoolObject::operator<(const MemoryPoolObject& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.id_ref() == rhs.id_ref())) {
    return lhs.id_ref() < rhs.id_ref();
  }
  if (!(lhs.maxSize_ref() == rhs.maxSize_ref())) {
    return lhs.maxSize_ref() < rhs.maxSize_ref();
  }
  if (!(lhs.currSlabAllocSize_ref() == rhs.currSlabAllocSize_ref())) {
    return lhs.currSlabAllocSize_ref() < rhs.currSlabAllocSize_ref();
  }
  if (!(lhs.currAllocSize_ref() == rhs.currAllocSize_ref())) {
    return lhs.currAllocSize_ref() < rhs.currAllocSize_ref();
  }
  if (!(lhs.acSizes_ref() == rhs.acSizes_ref())) {
    return lhs.acSizes_ref() < rhs.acSizes_ref();
  }
  if (!(lhs.ac_ref() == rhs.ac_ref())) {
    return lhs.ac_ref() < rhs.ac_ref();
  }
  if (!(lhs.numSlabResize_ref() == rhs.numSlabResize_ref())) {
    return lhs.numSlabResize_ref() < rhs.numSlabResize_ref();
  }
  if (!(lhs.numSlabRebalance_ref() == rhs.numSlabRebalance_ref())) {
    return lhs.numSlabRebalance_ref() < rhs.numSlabRebalance_ref();
  }
  if (!(lhs.freeSlabIdxs_ref() == rhs.freeSlabIdxs_ref())) {
    return lhs.freeSlabIdxs_ref() < rhs.freeSlabIdxs_ref();
  }
  if (!(lhs.numSlabsAdvised_ref() == rhs.numSlabsAdvised_ref())) {
    return lhs.numSlabsAdvised_ref() < rhs.numSlabsAdvised_ref();
  }
  return false;
}

const ::std::vector<::std::int64_t>& MemoryPoolObject::get_acSizes() const& {
  return acSizes;
}

::std::vector<::std::int64_t> MemoryPoolObject::get_acSizes() && {
  return std::move(acSizes);
}

const ::std::vector<::facebook::cachelib::serialization::AllocationClassObject>& MemoryPoolObject::get_ac() const& {
  return ac;
}

::std::vector<::facebook::cachelib::serialization::AllocationClassObject> MemoryPoolObject::get_ac() && {
  return std::move(ac);
}

const ::std::vector<::std::int32_t>& MemoryPoolObject::get_freeSlabIdxs() const& {
  return freeSlabIdxs;
}

::std::vector<::std::int32_t> MemoryPoolObject::get_freeSlabIdxs() && {
  return std::move(freeSlabIdxs);
}


void swap(MemoryPoolObject& a, MemoryPoolObject& b) {
  using ::std::swap;
  swap(a.id_ref().value(), b.id_ref().value());
  swap(a.maxSize_ref().value(), b.maxSize_ref().value());
  swap(a.currSlabAllocSize_ref().value(), b.currSlabAllocSize_ref().value());
  swap(a.currAllocSize_ref().value(), b.currAllocSize_ref().value());
  swap(a.acSizes_ref().value(), b.acSizes_ref().value());
  swap(a.ac_ref().value(), b.ac_ref().value());
  swap(a.numSlabResize_ref().value(), b.numSlabResize_ref().value());
  swap(a.numSlabRebalance_ref().value(), b.numSlabRebalance_ref().value());
  swap(a.freeSlabIdxs_ref().value(), b.freeSlabIdxs_ref().value());
  swap(a.numSlabsAdvised_ref().value(), b.numSlabsAdvised_ref().value());
  swap(a.__isset, b.__isset);
}

template void MemoryPoolObject::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MemoryPoolObject::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MemoryPoolObject::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MemoryPoolObject::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MemoryPoolObject::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MemoryPoolObject::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MemoryPoolObject::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MemoryPoolObject::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        MemoryPoolObject,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<::facebook::cachelib::serialization::AllocationClassObject>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        MemoryPoolObject,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<::facebook::cachelib::serialization::AllocationClassObject>>,
    "inconsistent use of nimble option");

}}} // facebook::cachelib::serialization

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::cachelib::serialization::MemoryPoolManagerObject>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::facebook::cachelib::serialization::MemoryPoolManagerObject>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace cachelib { namespace serialization {

MemoryPoolManagerObject::MemoryPoolManagerObject(const MemoryPoolManagerObject&) = default;
MemoryPoolManagerObject& MemoryPoolManagerObject::operator=(const MemoryPoolManagerObject&) = default;
MemoryPoolManagerObject::MemoryPoolManagerObject(MemoryPoolManagerObject&& other) noexcept  :
    __fbthrift_field_pools(std::move(other.__fbthrift_field_pools)),
    __fbthrift_field_poolsByName(std::move(other.__fbthrift_field_poolsByName)),
    __fbthrift_field_nextPoolId(std::move(other.__fbthrift_field_nextPoolId)),
    __isset(other.__isset) {
}

MemoryPoolManagerObject& MemoryPoolManagerObject::operator=(FOLLY_MAYBE_UNUSED MemoryPoolManagerObject&& other) noexcept {
    this->__fbthrift_field_pools = std::move(other.__fbthrift_field_pools);
    this->__fbthrift_field_poolsByName = std::move(other.__fbthrift_field_poolsByName);
    this->__fbthrift_field_nextPoolId = std::move(other.__fbthrift_field_nextPoolId);
    __isset = other.__isset;
    return *this;
}


MemoryPoolManagerObject::MemoryPoolManagerObject(apache::thrift::FragileConstructor, ::std::vector<::facebook::cachelib::serialization::MemoryPoolObject> pools__arg, ::std::map<::std::string, ::std::int8_t> poolsByName__arg, ::std::int8_t nextPoolId__arg) :
    __fbthrift_field_pools(std::move(pools__arg)),
    __fbthrift_field_poolsByName(std::move(poolsByName__arg)),
    __fbthrift_field_nextPoolId(std::move(nextPoolId__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
}


void MemoryPoolManagerObject::__clear() {
  // clear all fields
  this->__fbthrift_field_pools.clear();
  this->__fbthrift_field_poolsByName.clear();
  this->__fbthrift_field_nextPoolId = ::std::int8_t();
  __isset = {};
}

bool MemoryPoolManagerObject::operator==(const MemoryPoolManagerObject& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.pools_ref() == rhs.pools_ref())) {
    return false;
  }
  if (!(lhs.poolsByName_ref() == rhs.poolsByName_ref())) {
    return false;
  }
  if (!(lhs.nextPoolId_ref() == rhs.nextPoolId_ref())) {
    return false;
  }
  return true;
}

bool MemoryPoolManagerObject::operator<(const MemoryPoolManagerObject& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.pools_ref() == rhs.pools_ref())) {
    return lhs.pools_ref() < rhs.pools_ref();
  }
  if (!(lhs.poolsByName_ref() == rhs.poolsByName_ref())) {
    return lhs.poolsByName_ref() < rhs.poolsByName_ref();
  }
  if (!(lhs.nextPoolId_ref() == rhs.nextPoolId_ref())) {
    return lhs.nextPoolId_ref() < rhs.nextPoolId_ref();
  }
  return false;
}

const ::std::vector<::facebook::cachelib::serialization::MemoryPoolObject>& MemoryPoolManagerObject::get_pools() const& {
  return __fbthrift_field_pools;
}

::std::vector<::facebook::cachelib::serialization::MemoryPoolObject> MemoryPoolManagerObject::get_pools() && {
  return std::move(__fbthrift_field_pools);
}

const ::std::map<::std::string, ::std::int8_t>& MemoryPoolManagerObject::get_poolsByName() const& {
  return __fbthrift_field_poolsByName;
}

::std::map<::std::string, ::std::int8_t> MemoryPoolManagerObject::get_poolsByName() && {
  return std::move(__fbthrift_field_poolsByName);
}


void swap(MemoryPoolManagerObject& a, MemoryPoolManagerObject& b) {
  using ::std::swap;
  swap(a.pools_ref().value(), b.pools_ref().value());
  swap(a.poolsByName_ref().value(), b.poolsByName_ref().value());
  swap(a.nextPoolId_ref().value(), b.nextPoolId_ref().value());
  swap(a.__isset, b.__isset);
}

template void MemoryPoolManagerObject::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MemoryPoolManagerObject::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MemoryPoolManagerObject::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MemoryPoolManagerObject::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MemoryPoolManagerObject::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MemoryPoolManagerObject::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MemoryPoolManagerObject::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MemoryPoolManagerObject::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        MemoryPoolManagerObject,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<::facebook::cachelib::serialization::MemoryPoolObject>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        MemoryPoolManagerObject,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<::facebook::cachelib::serialization::MemoryPoolObject>>,
    "inconsistent use of nimble option");

}}} // facebook::cachelib::serialization

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::cachelib::serialization::MemoryAllocatorObject>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::facebook::cachelib::serialization::MemoryAllocatorObject>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace cachelib { namespace serialization {

MemoryAllocatorObject::MemoryAllocatorObject(const MemoryAllocatorObject&) = default;
MemoryAllocatorObject& MemoryAllocatorObject::operator=(const MemoryAllocatorObject&) = default;
MemoryAllocatorObject::MemoryAllocatorObject() :
      enableZeroedSlabAllocs(),
      __fbthrift_field_lockMemory(static_cast<bool>(false)) {
}


MemoryAllocatorObject::~MemoryAllocatorObject() {}

MemoryAllocatorObject::MemoryAllocatorObject(MemoryAllocatorObject&& other) noexcept  :
    allocSizes(std::move(other.allocSizes)),
    enableZeroedSlabAllocs(std::move(other.enableZeroedSlabAllocs)),
    __fbthrift_field_lockMemory(std::move(other.__fbthrift_field_lockMemory)),
    slabAllocator(std::move(other.slabAllocator)),
    memoryPoolManager(std::move(other.memoryPoolManager)),
    __isset(other.__isset) {
}

MemoryAllocatorObject& MemoryAllocatorObject::operator=(FOLLY_MAYBE_UNUSED MemoryAllocatorObject&& other) noexcept {
    this->allocSizes = std::move(other.allocSizes);
    this->enableZeroedSlabAllocs = std::move(other.enableZeroedSlabAllocs);
    this->__fbthrift_field_lockMemory = std::move(other.__fbthrift_field_lockMemory);
    this->slabAllocator = std::move(other.slabAllocator);
    this->memoryPoolManager = std::move(other.memoryPoolManager);
    __isset = other.__isset;
    return *this;
}


MemoryAllocatorObject::MemoryAllocatorObject(apache::thrift::FragileConstructor, ::std::set<::std::int64_t> allocSizes__arg, bool enableZeroedSlabAllocs__arg, bool lockMemory__arg, ::facebook::cachelib::serialization::SlabAllocatorObject slabAllocator__arg, ::facebook::cachelib::serialization::MemoryPoolManagerObject memoryPoolManager__arg) :
    allocSizes(std::move(allocSizes__arg)),
    enableZeroedSlabAllocs(std::move(enableZeroedSlabAllocs__arg)),
    __fbthrift_field_lockMemory(std::move(lockMemory__arg)),
    slabAllocator(std::move(slabAllocator__arg)),
    memoryPoolManager(std::move(memoryPoolManager__arg)) {
  __isset.set(folly::index_constant<0>(), true);
}


void MemoryAllocatorObject::__clear() {
  // clear all fields
  this->allocSizes.clear();
  this->enableZeroedSlabAllocs = bool();
  this->__fbthrift_field_lockMemory = static_cast<bool>(false);
  this->slabAllocator.__clear();
  this->memoryPoolManager.__clear();
  __isset = {};
}

bool MemoryAllocatorObject::operator==(const MemoryAllocatorObject& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.allocSizes_ref() == rhs.allocSizes_ref())) {
    return false;
  }
  if (!(lhs.enableZeroedSlabAllocs_ref() == rhs.enableZeroedSlabAllocs_ref())) {
    return false;
  }
  if (!(lhs.lockMemory_ref() == rhs.lockMemory_ref())) {
    return false;
  }
  if (!(lhs.slabAllocator_ref() == rhs.slabAllocator_ref())) {
    return false;
  }
  if (!(lhs.memoryPoolManager_ref() == rhs.memoryPoolManager_ref())) {
    return false;
  }
  return true;
}

bool MemoryAllocatorObject::operator<(const MemoryAllocatorObject& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.allocSizes_ref() == rhs.allocSizes_ref())) {
    return lhs.allocSizes_ref() < rhs.allocSizes_ref();
  }
  if (!(lhs.enableZeroedSlabAllocs_ref() == rhs.enableZeroedSlabAllocs_ref())) {
    return lhs.enableZeroedSlabAllocs_ref() < rhs.enableZeroedSlabAllocs_ref();
  }
  if (!(lhs.lockMemory_ref() == rhs.lockMemory_ref())) {
    return lhs.lockMemory_ref() < rhs.lockMemory_ref();
  }
  if (!(lhs.slabAllocator_ref() == rhs.slabAllocator_ref())) {
    return lhs.slabAllocator_ref() < rhs.slabAllocator_ref();
  }
  if (!(lhs.memoryPoolManager_ref() == rhs.memoryPoolManager_ref())) {
    return lhs.memoryPoolManager_ref() < rhs.memoryPoolManager_ref();
  }
  return false;
}

const ::std::set<::std::int64_t>& MemoryAllocatorObject::get_allocSizes() const& {
  return allocSizes;
}

::std::set<::std::int64_t> MemoryAllocatorObject::get_allocSizes() && {
  return std::move(allocSizes);
}

const ::facebook::cachelib::serialization::SlabAllocatorObject& MemoryAllocatorObject::get_slabAllocator() const& {
  return slabAllocator;
}

::facebook::cachelib::serialization::SlabAllocatorObject MemoryAllocatorObject::get_slabAllocator() && {
  return std::move(slabAllocator);
}

const ::facebook::cachelib::serialization::MemoryPoolManagerObject& MemoryAllocatorObject::get_memoryPoolManager() const& {
  return memoryPoolManager;
}

::facebook::cachelib::serialization::MemoryPoolManagerObject MemoryAllocatorObject::get_memoryPoolManager() && {
  return std::move(memoryPoolManager);
}


void swap(MemoryAllocatorObject& a, MemoryAllocatorObject& b) {
  using ::std::swap;
  swap(a.allocSizes_ref().value(), b.allocSizes_ref().value());
  swap(a.enableZeroedSlabAllocs_ref().value(), b.enableZeroedSlabAllocs_ref().value());
  swap(a.lockMemory_ref().value(), b.lockMemory_ref().value());
  swap(a.slabAllocator_ref().value(), b.slabAllocator_ref().value());
  swap(a.memoryPoolManager_ref().value(), b.memoryPoolManager_ref().value());
  swap(a.__isset, b.__isset);
}

template void MemoryAllocatorObject::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MemoryAllocatorObject::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MemoryAllocatorObject::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MemoryAllocatorObject::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MemoryAllocatorObject::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MemoryAllocatorObject::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MemoryAllocatorObject::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MemoryAllocatorObject::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        MemoryAllocatorObject,
        ::apache::thrift::type_class::structure,
        ::facebook::cachelib::serialization::SlabAllocatorObject>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        MemoryAllocatorObject,
        ::apache::thrift::type_class::structure,
        ::facebook::cachelib::serialization::MemoryPoolManagerObject>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        MemoryAllocatorObject,
        ::apache::thrift::type_class::structure,
        ::facebook::cachelib::serialization::SlabAllocatorObject>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        MemoryAllocatorObject,
        ::apache::thrift::type_class::structure,
        ::facebook::cachelib::serialization::MemoryPoolManagerObject>,
    "inconsistent use of nimble option");

}}} // facebook::cachelib::serialization

namespace facebook { namespace cachelib { namespace serialization { namespace {
FOLLY_MAYBE_UNUSED FOLLY_ERASE void validateAdapters() {
}
}}}} // facebook::cachelib::serialization
