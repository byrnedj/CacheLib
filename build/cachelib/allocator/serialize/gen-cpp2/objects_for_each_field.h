/**
 * Autogenerated by Thrift for objects.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */
#pragma once

#include "objects_metadata.h"
#include <thrift/lib/cpp2/visitation/for_each.h>

namespace apache {
namespace thrift {
namespace detail {

template <>
struct ForEachField<::facebook::cachelib::serialization::CacheAllocatorMetadata> {
  template <typename F, typename... T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, FOLLY_MAYBE_UNUSED T&&... t) const {
    f(0, static_cast<T&&>(t).allocatorVersion_ref()...);
    f(1, static_cast<T&&>(t).cacheCreationTime_ref()...);
    f(2, static_cast<T&&>(t).accessType_ref()...);
    f(3, static_cast<T&&>(t).mmType_ref()...);
    f(4, static_cast<T&&>(t).fragmentationSize_ref()...);
    f(5, static_cast<T&&>(t).compactCachePools_ref()...);
    f(6, static_cast<T&&>(t).numPermanentItems_ref()...);
    f(7, static_cast<T&&>(t).numChainedParentItems_ref()...);
    f(8, static_cast<T&&>(t).numChainedChildItems_ref()...);
    f(9, static_cast<T&&>(t).ramFormatVersion_ref()...);
    f(10, static_cast<T&&>(t).numAbortedSlabReleases_ref()...);
  }
};

template <>
struct ForEachField<::facebook::cachelib::serialization::NvmCacheMetadata> {
  template <typename F, typename... T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, FOLLY_MAYBE_UNUSED T&&... t) const {
    f(0, static_cast<T&&>(t).nvmFormatVersion_ref()...);
    f(1, static_cast<T&&>(t).creationTime_ref()...);
    f(2, static_cast<T&&>(t).safeShutDown_ref()...);
    f(3, static_cast<T&&>(t).encryptionEnabled_ref()...);
    f(4, static_cast<T&&>(t).truncateAllocSize_ref()...);
  }
};

template <>
struct ForEachField<::facebook::cachelib::serialization::CompactCacheMetadataObject> {
  template <typename F, typename... T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, FOLLY_MAYBE_UNUSED T&&... t) const {
    f(0, static_cast<T&&>(t).keySize_ref()...);
    f(1, static_cast<T&&>(t).valueSize_ref()...);
  }
};

template <>
struct ForEachField<::facebook::cachelib::serialization::CompactCacheAllocatorObject> {
  template <typename F, typename... T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, FOLLY_MAYBE_UNUSED T&&... t) const {
    f(0, static_cast<T&&>(t).chunks_ref()...);
    f(1, static_cast<T&&>(t).ccMetadata_ref()...);
  }
};

template <>
struct ForEachField<::facebook::cachelib::serialization::CompactCacheAllocatorManagerObject> {
  template <typename F, typename... T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, FOLLY_MAYBE_UNUSED T&&... t) const {
    f(0, static_cast<T&&>(t).allocators_ref()...);
  }
};

template <>
struct ForEachField<::facebook::cachelib::serialization::MMLruConfig> {
  template <typename F, typename... T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, FOLLY_MAYBE_UNUSED T&&... t) const {
    f(0, static_cast<T&&>(t).lruRefreshTime_ref()...);
    f(1, static_cast<T&&>(t).updateOnWrite_ref()...);
    f(2, static_cast<T&&>(t).lruInsertionPointSpec_ref()...);
    f(3, static_cast<T&&>(t).updateOnRead_ref()...);
    f(4, static_cast<T&&>(t).tryLockUpdate_ref()...);
    f(5, static_cast<T&&>(t).lruRefreshRatio_ref()...);
  }
};

template <>
struct ForEachField<::facebook::cachelib::serialization::MMLruObject> {
  template <typename F, typename... T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, FOLLY_MAYBE_UNUSED T&&... t) const {
    f(0, static_cast<T&&>(t).config_ref()...);
    f(1, static_cast<T&&>(t).evictions_ref()...);
    f(2, static_cast<T&&>(t).insertionPoint_ref()...);
    f(3, static_cast<T&&>(t).tailSize_ref()...);
    f(4, static_cast<T&&>(t).lru_ref()...);
    f(5, static_cast<T&&>(t).compressedInsertionPoint_ref()...);
  }
};

template <>
struct ForEachField<::facebook::cachelib::serialization::MMLruCollection> {
  template <typename F, typename... T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, FOLLY_MAYBE_UNUSED T&&... t) const {
    f(0, static_cast<T&&>(t).pools_ref()...);
  }
};

template <>
struct ForEachField<::facebook::cachelib::serialization::MM2QConfig> {
  template <typename F, typename... T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, FOLLY_MAYBE_UNUSED T&&... t) const {
    f(0, static_cast<T&&>(t).lruRefreshTime_ref()...);
    f(1, static_cast<T&&>(t).updateOnWrite_ref()...);
    f(2, static_cast<T&&>(t).hotSizePercent_ref()...);
    f(3, static_cast<T&&>(t).coldSizePercent_ref()...);
    f(4, static_cast<T&&>(t).updateOnRead_ref()...);
    f(5, static_cast<T&&>(t).tryLockUpdate_ref()...);
    f(6, static_cast<T&&>(t).rebalanceOnRecordAccess_ref()...);
    f(7, static_cast<T&&>(t).lruRefreshRatio_ref()...);
  }
};

template <>
struct ForEachField<::facebook::cachelib::serialization::MM2QObject> {
  template <typename F, typename... T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, FOLLY_MAYBE_UNUSED T&&... t) const {
    f(0, static_cast<T&&>(t).config_ref()...);
    f(1, static_cast<T&&>(t).tailTrackingEnabled_ref()...);
    f(2, static_cast<T&&>(t).evictions_ref()...);
    f(3, static_cast<T&&>(t).lrus_ref()...);
  }
};

template <>
struct ForEachField<::facebook::cachelib::serialization::MM2QCollection> {
  template <typename F, typename... T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, FOLLY_MAYBE_UNUSED T&&... t) const {
    f(0, static_cast<T&&>(t).pools_ref()...);
  }
};

template <>
struct ForEachField<::facebook::cachelib::serialization::MMTinyLFUConfig> {
  template <typename F, typename... T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, FOLLY_MAYBE_UNUSED T&&... t) const {
    f(0, static_cast<T&&>(t).lruRefreshTime_ref()...);
    f(1, static_cast<T&&>(t).updateOnWrite_ref()...);
    f(2, static_cast<T&&>(t).windowToCacheSizeRatio_ref()...);
    f(3, static_cast<T&&>(t).tinySizePercent_ref()...);
    f(4, static_cast<T&&>(t).updateOnRead_ref()...);
    f(5, static_cast<T&&>(t).tryLockUpdate_ref()...);
    f(6, static_cast<T&&>(t).lruRefreshRatio_ref()...);
  }
};

template <>
struct ForEachField<::facebook::cachelib::serialization::MMTinyLFUObject> {
  template <typename F, typename... T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, FOLLY_MAYBE_UNUSED T&&... t) const {
    f(0, static_cast<T&&>(t).config_ref()...);
    f(1, static_cast<T&&>(t).evictions_ref()...);
    f(2, static_cast<T&&>(t).lrus_ref()...);
  }
};

template <>
struct ForEachField<::facebook::cachelib::serialization::MMTinyLFUCollection> {
  template <typename F, typename... T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, FOLLY_MAYBE_UNUSED T&&... t) const {
    f(0, static_cast<T&&>(t).pools_ref()...);
  }
};

template <>
struct ForEachField<::facebook::cachelib::serialization::ChainedHashTableObject> {
  template <typename F, typename... T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, FOLLY_MAYBE_UNUSED T&&... t) const {
    f(0, static_cast<T&&>(t).bucketsPower_ref()...);
    f(1, static_cast<T&&>(t).locksPower_ref()...);
    f(2, static_cast<T&&>(t).numKeys_ref()...);
    f(3, static_cast<T&&>(t).hasherMagicId_ref()...);
  }
};

template <>
struct ForEachField<::facebook::cachelib::serialization::MMTTLBucketObject> {
  template <typename F, typename... T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, FOLLY_MAYBE_UNUSED T&&... t) const {
    f(0, static_cast<T&&>(t).expirationTime_ref()...);
    f(1, static_cast<T&&>(t).creationTime_ref()...);
    f(2, static_cast<T&&>(t).dList_ref()...);
  }
};

template <>
struct ForEachField<::facebook::cachelib::serialization::TTLBucketCollection> {
  template <typename F, typename... T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, FOLLY_MAYBE_UNUSED T&&... t) const {
    f(0, static_cast<T&&>(t).buckets_ref()...);
    f(1, static_cast<T&&>(t).minEpoch_ref()...);
    f(2, static_cast<T&&>(t).maxTTL_ref()...);
    f(3, static_cast<T&&>(t).interval_ref()...);
  }
};
} // namespace detail
} // namespace thrift
} // namespace apache
