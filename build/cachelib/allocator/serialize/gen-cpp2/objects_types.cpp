/**
 * Autogenerated by Thrift for objects.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */
#include "objects_types.h"
#include "objects_types.tcc"

#include <thrift/lib/cpp2/gen/module_types_cpp.h>

#include "objects_data.h"


namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::cachelib::serialization::CacheAllocatorMetadata>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::facebook::cachelib::serialization::CacheAllocatorMetadata>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace cachelib { namespace serialization {

CacheAllocatorMetadata::CacheAllocatorMetadata(const CacheAllocatorMetadata&) = default;
CacheAllocatorMetadata& CacheAllocatorMetadata::operator=(const CacheAllocatorMetadata&) = default;
CacheAllocatorMetadata::CacheAllocatorMetadata() :
      allocatorVersion(),
      __fbthrift_field_cacheCreationTime(static_cast<::std::int64_t>(0)),
      accessType(static_cast<::std::int64_t>(0)),
      mmType(static_cast<::std::int64_t>(0)),
      __fbthrift_field_numPermanentItems(),
      __fbthrift_field_numChainedParentItems(),
      __fbthrift_field_numChainedChildItems(),
      __fbthrift_field_ramFormatVersion(static_cast<::std::int64_t>(0)),
      __fbthrift_field_numAbortedSlabReleases(static_cast<::std::int64_t>(0)) {
}


CacheAllocatorMetadata::~CacheAllocatorMetadata() {}

CacheAllocatorMetadata::CacheAllocatorMetadata(CacheAllocatorMetadata&& other) noexcept  :
    allocatorVersion(std::move(other.allocatorVersion)),
    __fbthrift_field_cacheCreationTime(std::move(other.__fbthrift_field_cacheCreationTime)),
    accessType(std::move(other.accessType)),
    mmType(std::move(other.mmType)),
    __fbthrift_field_fragmentationSize(std::move(other.__fbthrift_field_fragmentationSize)),
    __fbthrift_field_compactCachePools(std::move(other.__fbthrift_field_compactCachePools)),
    __fbthrift_field_numPermanentItems(std::move(other.__fbthrift_field_numPermanentItems)),
    __fbthrift_field_numChainedParentItems(std::move(other.__fbthrift_field_numChainedParentItems)),
    __fbthrift_field_numChainedChildItems(std::move(other.__fbthrift_field_numChainedChildItems)),
    __fbthrift_field_ramFormatVersion(std::move(other.__fbthrift_field_ramFormatVersion)),
    __fbthrift_field_numAbortedSlabReleases(std::move(other.__fbthrift_field_numAbortedSlabReleases)),
    __isset(other.__isset) {
}

CacheAllocatorMetadata& CacheAllocatorMetadata::operator=(FOLLY_MAYBE_UNUSED CacheAllocatorMetadata&& other) noexcept {
    this->allocatorVersion = std::move(other.allocatorVersion);
    this->__fbthrift_field_cacheCreationTime = std::move(other.__fbthrift_field_cacheCreationTime);
    this->accessType = std::move(other.accessType);
    this->mmType = std::move(other.mmType);
    this->__fbthrift_field_fragmentationSize = std::move(other.__fbthrift_field_fragmentationSize);
    this->__fbthrift_field_compactCachePools = std::move(other.__fbthrift_field_compactCachePools);
    this->__fbthrift_field_numPermanentItems = std::move(other.__fbthrift_field_numPermanentItems);
    this->__fbthrift_field_numChainedParentItems = std::move(other.__fbthrift_field_numChainedParentItems);
    this->__fbthrift_field_numChainedChildItems = std::move(other.__fbthrift_field_numChainedChildItems);
    this->__fbthrift_field_ramFormatVersion = std::move(other.__fbthrift_field_ramFormatVersion);
    this->__fbthrift_field_numAbortedSlabReleases = std::move(other.__fbthrift_field_numAbortedSlabReleases);
    __isset = other.__isset;
    return *this;
}


CacheAllocatorMetadata::CacheAllocatorMetadata(apache::thrift::FragileConstructor, ::std::int64_t allocatorVersion__arg, ::std::int64_t cacheCreationTime__arg, ::std::int64_t accessType__arg, ::std::int64_t mmType__arg, ::std::map<::std::int8_t, ::std::map<::std::int8_t, ::std::int64_t>> fragmentationSize__arg, ::std::vector<::std::int8_t> compactCachePools__arg, ::std::int64_t numPermanentItems__arg, ::std::int64_t numChainedParentItems__arg, ::std::int64_t numChainedChildItems__arg, ::std::int64_t ramFormatVersion__arg, ::std::int64_t numAbortedSlabReleases__arg) :
    allocatorVersion(std::move(allocatorVersion__arg)),
    __fbthrift_field_cacheCreationTime(std::move(cacheCreationTime__arg)),
    accessType(std::move(accessType__arg)),
    mmType(std::move(mmType__arg)),
    __fbthrift_field_fragmentationSize(std::move(fragmentationSize__arg)),
    __fbthrift_field_compactCachePools(std::move(compactCachePools__arg)),
    __fbthrift_field_numPermanentItems(std::move(numPermanentItems__arg)),
    __fbthrift_field_numChainedParentItems(std::move(numChainedParentItems__arg)),
    __fbthrift_field_numChainedChildItems(std::move(numChainedChildItems__arg)),
    __fbthrift_field_ramFormatVersion(std::move(ramFormatVersion__arg)),
    __fbthrift_field_numAbortedSlabReleases(std::move(numAbortedSlabReleases__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
  __isset.set(folly::index_constant<3>(), true);
  __isset.set(folly::index_constant<4>(), true);
  __isset.set(folly::index_constant<5>(), true);
  __isset.set(folly::index_constant<6>(), true);
  __isset.set(folly::index_constant<7>(), true);
}


void CacheAllocatorMetadata::__clear() {
  // clear all fields
  this->allocatorVersion = ::std::int64_t();
  this->__fbthrift_field_cacheCreationTime = static_cast<::std::int64_t>(0);
  this->accessType = static_cast<::std::int64_t>(0);
  this->mmType = static_cast<::std::int64_t>(0);
  this->__fbthrift_field_fragmentationSize.clear();
  this->__fbthrift_field_compactCachePools.clear();
  this->__fbthrift_field_numPermanentItems = ::std::int64_t();
  this->__fbthrift_field_numChainedParentItems = ::std::int64_t();
  this->__fbthrift_field_numChainedChildItems = ::std::int64_t();
  this->__fbthrift_field_ramFormatVersion = static_cast<::std::int64_t>(0);
  this->__fbthrift_field_numAbortedSlabReleases = static_cast<::std::int64_t>(0);
  __isset = {};
}

bool CacheAllocatorMetadata::operator==(const CacheAllocatorMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.allocatorVersion_ref() == rhs.allocatorVersion_ref())) {
    return false;
  }
  if (!(lhs.cacheCreationTime_ref() == rhs.cacheCreationTime_ref())) {
    return false;
  }
  if (!(lhs.accessType_ref() == rhs.accessType_ref())) {
    return false;
  }
  if (!(lhs.mmType_ref() == rhs.mmType_ref())) {
    return false;
  }
  if (!(lhs.fragmentationSize_ref() == rhs.fragmentationSize_ref())) {
    return false;
  }
  if (!(lhs.compactCachePools_ref() == rhs.compactCachePools_ref())) {
    return false;
  }
  if (!(lhs.numPermanentItems_ref() == rhs.numPermanentItems_ref())) {
    return false;
  }
  if (!(lhs.numChainedParentItems_ref() == rhs.numChainedParentItems_ref())) {
    return false;
  }
  if (!(lhs.numChainedChildItems_ref() == rhs.numChainedChildItems_ref())) {
    return false;
  }
  if (!(lhs.ramFormatVersion_ref() == rhs.ramFormatVersion_ref())) {
    return false;
  }
  if (!(lhs.numAbortedSlabReleases_ref() == rhs.numAbortedSlabReleases_ref())) {
    return false;
  }
  return true;
}

bool CacheAllocatorMetadata::operator<(const CacheAllocatorMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.allocatorVersion_ref() == rhs.allocatorVersion_ref())) {
    return lhs.allocatorVersion_ref() < rhs.allocatorVersion_ref();
  }
  if (!(lhs.cacheCreationTime_ref() == rhs.cacheCreationTime_ref())) {
    return lhs.cacheCreationTime_ref() < rhs.cacheCreationTime_ref();
  }
  if (!(lhs.accessType_ref() == rhs.accessType_ref())) {
    return lhs.accessType_ref() < rhs.accessType_ref();
  }
  if (!(lhs.mmType_ref() == rhs.mmType_ref())) {
    return lhs.mmType_ref() < rhs.mmType_ref();
  }
  if (!(lhs.fragmentationSize_ref() == rhs.fragmentationSize_ref())) {
    return lhs.fragmentationSize_ref() < rhs.fragmentationSize_ref();
  }
  if (!(lhs.compactCachePools_ref() == rhs.compactCachePools_ref())) {
    return lhs.compactCachePools_ref() < rhs.compactCachePools_ref();
  }
  if (!(lhs.numPermanentItems_ref() == rhs.numPermanentItems_ref())) {
    return lhs.numPermanentItems_ref() < rhs.numPermanentItems_ref();
  }
  if (!(lhs.numChainedParentItems_ref() == rhs.numChainedParentItems_ref())) {
    return lhs.numChainedParentItems_ref() < rhs.numChainedParentItems_ref();
  }
  if (!(lhs.numChainedChildItems_ref() == rhs.numChainedChildItems_ref())) {
    return lhs.numChainedChildItems_ref() < rhs.numChainedChildItems_ref();
  }
  if (!(lhs.ramFormatVersion_ref() == rhs.ramFormatVersion_ref())) {
    return lhs.ramFormatVersion_ref() < rhs.ramFormatVersion_ref();
  }
  if (!(lhs.numAbortedSlabReleases_ref() == rhs.numAbortedSlabReleases_ref())) {
    return lhs.numAbortedSlabReleases_ref() < rhs.numAbortedSlabReleases_ref();
  }
  return false;
}

const ::std::map<::std::int8_t, ::std::map<::std::int8_t, ::std::int64_t>>& CacheAllocatorMetadata::get_fragmentationSize() const& {
  return __fbthrift_field_fragmentationSize;
}

::std::map<::std::int8_t, ::std::map<::std::int8_t, ::std::int64_t>> CacheAllocatorMetadata::get_fragmentationSize() && {
  return std::move(__fbthrift_field_fragmentationSize);
}

const ::std::vector<::std::int8_t>& CacheAllocatorMetadata::get_compactCachePools() const& {
  return __fbthrift_field_compactCachePools;
}

::std::vector<::std::int8_t> CacheAllocatorMetadata::get_compactCachePools() && {
  return std::move(__fbthrift_field_compactCachePools);
}


void swap(CacheAllocatorMetadata& a, CacheAllocatorMetadata& b) {
  using ::std::swap;
  swap(a.allocatorVersion_ref().value(), b.allocatorVersion_ref().value());
  swap(a.cacheCreationTime_ref().value(), b.cacheCreationTime_ref().value());
  swap(a.accessType_ref().value(), b.accessType_ref().value());
  swap(a.mmType_ref().value(), b.mmType_ref().value());
  swap(a.fragmentationSize_ref().value(), b.fragmentationSize_ref().value());
  swap(a.compactCachePools_ref().value(), b.compactCachePools_ref().value());
  swap(a.numPermanentItems_ref().value(), b.numPermanentItems_ref().value());
  swap(a.numChainedParentItems_ref().value(), b.numChainedParentItems_ref().value());
  swap(a.numChainedChildItems_ref().value(), b.numChainedChildItems_ref().value());
  swap(a.ramFormatVersion_ref().value(), b.ramFormatVersion_ref().value());
  swap(a.numAbortedSlabReleases_ref().value(), b.numAbortedSlabReleases_ref().value());
  swap(a.__isset, b.__isset);
}

template void CacheAllocatorMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t CacheAllocatorMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t CacheAllocatorMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t CacheAllocatorMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void CacheAllocatorMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t CacheAllocatorMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t CacheAllocatorMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t CacheAllocatorMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::cachelib::serialization

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::cachelib::serialization::NvmCacheMetadata>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::facebook::cachelib::serialization::NvmCacheMetadata>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace cachelib { namespace serialization {


NvmCacheMetadata::NvmCacheMetadata(apache::thrift::FragileConstructor, ::std::int64_t nvmFormatVersion__arg, ::std::int64_t creationTime__arg, bool safeShutDown__arg, bool encryptionEnabled__arg, bool truncateAllocSize__arg) :
    __fbthrift_field_nvmFormatVersion(std::move(nvmFormatVersion__arg)),
    __fbthrift_field_creationTime(std::move(creationTime__arg)),
    __fbthrift_field_safeShutDown(std::move(safeShutDown__arg)),
    __fbthrift_field_encryptionEnabled(std::move(encryptionEnabled__arg)),
    __fbthrift_field_truncateAllocSize(std::move(truncateAllocSize__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
  __isset.set(folly::index_constant<3>(), true);
  __isset.set(folly::index_constant<4>(), true);
}


void NvmCacheMetadata::__clear() {
  // clear all fields
  this->__fbthrift_field_nvmFormatVersion = static_cast<::std::int64_t>(0);
  this->__fbthrift_field_creationTime = static_cast<::std::int64_t>(0);
  this->__fbthrift_field_safeShutDown = static_cast<bool>(false);
  this->__fbthrift_field_encryptionEnabled = static_cast<bool>(false);
  this->__fbthrift_field_truncateAllocSize = static_cast<bool>(false);
  __isset = {};
}

bool NvmCacheMetadata::operator==(const NvmCacheMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.nvmFormatVersion_ref() == rhs.nvmFormatVersion_ref())) {
    return false;
  }
  if (!(lhs.creationTime_ref() == rhs.creationTime_ref())) {
    return false;
  }
  if (!(lhs.safeShutDown_ref() == rhs.safeShutDown_ref())) {
    return false;
  }
  if (!(lhs.encryptionEnabled_ref() == rhs.encryptionEnabled_ref())) {
    return false;
  }
  if (!(lhs.truncateAllocSize_ref() == rhs.truncateAllocSize_ref())) {
    return false;
  }
  return true;
}

bool NvmCacheMetadata::operator<(const NvmCacheMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.nvmFormatVersion_ref() == rhs.nvmFormatVersion_ref())) {
    return lhs.nvmFormatVersion_ref() < rhs.nvmFormatVersion_ref();
  }
  if (!(lhs.creationTime_ref() == rhs.creationTime_ref())) {
    return lhs.creationTime_ref() < rhs.creationTime_ref();
  }
  if (!(lhs.safeShutDown_ref() == rhs.safeShutDown_ref())) {
    return lhs.safeShutDown_ref() < rhs.safeShutDown_ref();
  }
  if (!(lhs.encryptionEnabled_ref() == rhs.encryptionEnabled_ref())) {
    return lhs.encryptionEnabled_ref() < rhs.encryptionEnabled_ref();
  }
  if (!(lhs.truncateAllocSize_ref() == rhs.truncateAllocSize_ref())) {
    return lhs.truncateAllocSize_ref() < rhs.truncateAllocSize_ref();
  }
  return false;
}


void swap(NvmCacheMetadata& a, NvmCacheMetadata& b) {
  using ::std::swap;
  swap(a.nvmFormatVersion_ref().value(), b.nvmFormatVersion_ref().value());
  swap(a.creationTime_ref().value(), b.creationTime_ref().value());
  swap(a.safeShutDown_ref().value(), b.safeShutDown_ref().value());
  swap(a.encryptionEnabled_ref().value(), b.encryptionEnabled_ref().value());
  swap(a.truncateAllocSize_ref().value(), b.truncateAllocSize_ref().value());
  swap(a.__isset, b.__isset);
}

template void NvmCacheMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t NvmCacheMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t NvmCacheMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t NvmCacheMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void NvmCacheMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t NvmCacheMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t NvmCacheMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t NvmCacheMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::cachelib::serialization

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::cachelib::serialization::CompactCacheMetadataObject>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::facebook::cachelib::serialization::CompactCacheMetadataObject>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace cachelib { namespace serialization {


CompactCacheMetadataObject::CompactCacheMetadataObject(apache::thrift::FragileConstructor, ::std::int64_t keySize__arg, ::std::int64_t valueSize__arg) :
    keySize(std::move(keySize__arg)),
    valueSize(std::move(valueSize__arg)) {
}


void CompactCacheMetadataObject::__clear() {
  // clear all fields
  this->keySize = ::std::int64_t();
  this->valueSize = ::std::int64_t();
}

bool CompactCacheMetadataObject::operator==(const CompactCacheMetadataObject& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.keySize_ref() == rhs.keySize_ref())) {
    return false;
  }
  if (!(lhs.valueSize_ref() == rhs.valueSize_ref())) {
    return false;
  }
  return true;
}

bool CompactCacheMetadataObject::operator<(const CompactCacheMetadataObject& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.keySize_ref() == rhs.keySize_ref())) {
    return lhs.keySize_ref() < rhs.keySize_ref();
  }
  if (!(lhs.valueSize_ref() == rhs.valueSize_ref())) {
    return lhs.valueSize_ref() < rhs.valueSize_ref();
  }
  return false;
}


void swap(CompactCacheMetadataObject& a, CompactCacheMetadataObject& b) {
  using ::std::swap;
  swap(a.keySize_ref().value(), b.keySize_ref().value());
  swap(a.valueSize_ref().value(), b.valueSize_ref().value());
}

template void CompactCacheMetadataObject::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t CompactCacheMetadataObject::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t CompactCacheMetadataObject::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t CompactCacheMetadataObject::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void CompactCacheMetadataObject::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t CompactCacheMetadataObject::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t CompactCacheMetadataObject::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t CompactCacheMetadataObject::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::cachelib::serialization

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::cachelib::serialization::CompactCacheAllocatorObject>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::facebook::cachelib::serialization::CompactCacheAllocatorObject>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace cachelib { namespace serialization {

CompactCacheAllocatorObject::CompactCacheAllocatorObject(const CompactCacheAllocatorObject&) = default;
CompactCacheAllocatorObject& CompactCacheAllocatorObject::operator=(const CompactCacheAllocatorObject&) = default;
CompactCacheAllocatorObject::CompactCacheAllocatorObject(CompactCacheAllocatorObject&& other) noexcept  :
    chunks(std::move(other.chunks)),
    ccMetadata(std::move(other.ccMetadata)) {
}

CompactCacheAllocatorObject& CompactCacheAllocatorObject::operator=(FOLLY_MAYBE_UNUSED CompactCacheAllocatorObject&& other) noexcept {
    this->chunks = std::move(other.chunks);
    this->ccMetadata = std::move(other.ccMetadata);
    return *this;
}


CompactCacheAllocatorObject::CompactCacheAllocatorObject(apache::thrift::FragileConstructor, ::std::vector<::std::int64_t> chunks__arg, ::facebook::cachelib::serialization::CompactCacheMetadataObject ccMetadata__arg) :
    chunks(std::move(chunks__arg)),
    ccMetadata(std::move(ccMetadata__arg)) {
}


void CompactCacheAllocatorObject::__clear() {
  // clear all fields
  this->chunks.clear();
  this->ccMetadata.__clear();
}

bool CompactCacheAllocatorObject::operator==(const CompactCacheAllocatorObject& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.chunks_ref() == rhs.chunks_ref())) {
    return false;
  }
  if (!(lhs.ccMetadata_ref() == rhs.ccMetadata_ref())) {
    return false;
  }
  return true;
}

bool CompactCacheAllocatorObject::operator<(const CompactCacheAllocatorObject& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.chunks_ref() == rhs.chunks_ref())) {
    return lhs.chunks_ref() < rhs.chunks_ref();
  }
  if (!(lhs.ccMetadata_ref() == rhs.ccMetadata_ref())) {
    return lhs.ccMetadata_ref() < rhs.ccMetadata_ref();
  }
  return false;
}

const ::std::vector<::std::int64_t>& CompactCacheAllocatorObject::get_chunks() const& {
  return chunks;
}

::std::vector<::std::int64_t> CompactCacheAllocatorObject::get_chunks() && {
  return std::move(chunks);
}

const ::facebook::cachelib::serialization::CompactCacheMetadataObject& CompactCacheAllocatorObject::get_ccMetadata() const& {
  return ccMetadata;
}

::facebook::cachelib::serialization::CompactCacheMetadataObject CompactCacheAllocatorObject::get_ccMetadata() && {
  return std::move(ccMetadata);
}


void swap(CompactCacheAllocatorObject& a, CompactCacheAllocatorObject& b) {
  using ::std::swap;
  swap(a.chunks_ref().value(), b.chunks_ref().value());
  swap(a.ccMetadata_ref().value(), b.ccMetadata_ref().value());
}

template void CompactCacheAllocatorObject::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t CompactCacheAllocatorObject::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t CompactCacheAllocatorObject::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t CompactCacheAllocatorObject::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void CompactCacheAllocatorObject::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t CompactCacheAllocatorObject::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t CompactCacheAllocatorObject::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t CompactCacheAllocatorObject::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        CompactCacheAllocatorObject,
        ::apache::thrift::type_class::structure,
        ::facebook::cachelib::serialization::CompactCacheMetadataObject>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        CompactCacheAllocatorObject,
        ::apache::thrift::type_class::structure,
        ::facebook::cachelib::serialization::CompactCacheMetadataObject>,
    "inconsistent use of nimble option");

}}} // facebook::cachelib::serialization

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::cachelib::serialization::CompactCacheAllocatorManagerObject>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::facebook::cachelib::serialization::CompactCacheAllocatorManagerObject>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace cachelib { namespace serialization {

CompactCacheAllocatorManagerObject::CompactCacheAllocatorManagerObject(const CompactCacheAllocatorManagerObject&) = default;
CompactCacheAllocatorManagerObject& CompactCacheAllocatorManagerObject::operator=(const CompactCacheAllocatorManagerObject&) = default;
CompactCacheAllocatorManagerObject::CompactCacheAllocatorManagerObject(CompactCacheAllocatorManagerObject&& other) noexcept  :
    allocators(std::move(other.allocators)) {
}

CompactCacheAllocatorManagerObject& CompactCacheAllocatorManagerObject::operator=(FOLLY_MAYBE_UNUSED CompactCacheAllocatorManagerObject&& other) noexcept {
    this->allocators = std::move(other.allocators);
    return *this;
}


CompactCacheAllocatorManagerObject::CompactCacheAllocatorManagerObject(apache::thrift::FragileConstructor, ::std::map<::std::string, ::facebook::cachelib::serialization::CompactCacheAllocatorObject> allocators__arg) :
    allocators(std::move(allocators__arg)) {
}


void CompactCacheAllocatorManagerObject::__clear() {
  // clear all fields
  this->allocators.clear();
}

bool CompactCacheAllocatorManagerObject::operator==(const CompactCacheAllocatorManagerObject& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.allocators_ref() == rhs.allocators_ref())) {
    return false;
  }
  return true;
}

bool CompactCacheAllocatorManagerObject::operator<(const CompactCacheAllocatorManagerObject& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.allocators_ref() == rhs.allocators_ref())) {
    return lhs.allocators_ref() < rhs.allocators_ref();
  }
  return false;
}

const ::std::map<::std::string, ::facebook::cachelib::serialization::CompactCacheAllocatorObject>& CompactCacheAllocatorManagerObject::get_allocators() const& {
  return allocators;
}

::std::map<::std::string, ::facebook::cachelib::serialization::CompactCacheAllocatorObject> CompactCacheAllocatorManagerObject::get_allocators() && {
  return std::move(allocators);
}


void swap(CompactCacheAllocatorManagerObject& a, CompactCacheAllocatorManagerObject& b) {
  using ::std::swap;
  swap(a.allocators_ref().value(), b.allocators_ref().value());
}

template void CompactCacheAllocatorManagerObject::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t CompactCacheAllocatorManagerObject::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t CompactCacheAllocatorManagerObject::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t CompactCacheAllocatorManagerObject::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void CompactCacheAllocatorManagerObject::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t CompactCacheAllocatorManagerObject::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t CompactCacheAllocatorManagerObject::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t CompactCacheAllocatorManagerObject::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        CompactCacheAllocatorManagerObject,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::structure>,
        ::std::map<::std::string, ::facebook::cachelib::serialization::CompactCacheAllocatorObject>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        CompactCacheAllocatorManagerObject,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::structure>,
        ::std::map<::std::string, ::facebook::cachelib::serialization::CompactCacheAllocatorObject>>,
    "inconsistent use of nimble option");

}}} // facebook::cachelib::serialization

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::cachelib::serialization::MMLruConfig>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::facebook::cachelib::serialization::MMLruConfig>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace cachelib { namespace serialization {


MMLruConfig::MMLruConfig(apache::thrift::FragileConstructor, ::std::int32_t lruRefreshTime__arg, bool updateOnWrite__arg, ::std::int32_t lruInsertionPointSpec__arg, bool updateOnRead__arg, bool tryLockUpdate__arg, double lruRefreshRatio__arg) :
    lruRefreshTime(std::move(lruRefreshTime__arg)),
    updateOnWrite(std::move(updateOnWrite__arg)),
    lruInsertionPointSpec(std::move(lruInsertionPointSpec__arg)),
    __fbthrift_field_updateOnRead(std::move(updateOnRead__arg)),
    __fbthrift_field_tryLockUpdate(std::move(tryLockUpdate__arg)),
    __fbthrift_field_lruRefreshRatio(std::move(lruRefreshRatio__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
}


void MMLruConfig::__clear() {
  // clear all fields
  this->lruRefreshTime = ::std::int32_t();
  this->updateOnWrite = bool();
  this->lruInsertionPointSpec = ::std::int32_t();
  this->__fbthrift_field_updateOnRead = static_cast<bool>(true);
  this->__fbthrift_field_tryLockUpdate = static_cast<bool>(false);
  this->__fbthrift_field_lruRefreshRatio = static_cast<double>(0);
  __isset = {};
}

bool MMLruConfig::operator==(const MMLruConfig& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.lruRefreshTime_ref() == rhs.lruRefreshTime_ref())) {
    return false;
  }
  if (!(lhs.updateOnWrite_ref() == rhs.updateOnWrite_ref())) {
    return false;
  }
  if (!(lhs.lruInsertionPointSpec_ref() == rhs.lruInsertionPointSpec_ref())) {
    return false;
  }
  if (!(lhs.updateOnRead_ref() == rhs.updateOnRead_ref())) {
    return false;
  }
  if (!(lhs.tryLockUpdate_ref() == rhs.tryLockUpdate_ref())) {
    return false;
  }
  if (!(lhs.lruRefreshRatio_ref() == rhs.lruRefreshRatio_ref())) {
    return false;
  }
  return true;
}

bool MMLruConfig::operator<(const MMLruConfig& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.lruRefreshTime_ref() == rhs.lruRefreshTime_ref())) {
    return lhs.lruRefreshTime_ref() < rhs.lruRefreshTime_ref();
  }
  if (!(lhs.updateOnWrite_ref() == rhs.updateOnWrite_ref())) {
    return lhs.updateOnWrite_ref() < rhs.updateOnWrite_ref();
  }
  if (!(lhs.lruInsertionPointSpec_ref() == rhs.lruInsertionPointSpec_ref())) {
    return lhs.lruInsertionPointSpec_ref() < rhs.lruInsertionPointSpec_ref();
  }
  if (!(lhs.updateOnRead_ref() == rhs.updateOnRead_ref())) {
    return lhs.updateOnRead_ref() < rhs.updateOnRead_ref();
  }
  if (!(lhs.tryLockUpdate_ref() == rhs.tryLockUpdate_ref())) {
    return lhs.tryLockUpdate_ref() < rhs.tryLockUpdate_ref();
  }
  if (!(lhs.lruRefreshRatio_ref() == rhs.lruRefreshRatio_ref())) {
    return lhs.lruRefreshRatio_ref() < rhs.lruRefreshRatio_ref();
  }
  return false;
}


void swap(MMLruConfig& a, MMLruConfig& b) {
  using ::std::swap;
  swap(a.lruRefreshTime_ref().value(), b.lruRefreshTime_ref().value());
  swap(a.updateOnWrite_ref().value(), b.updateOnWrite_ref().value());
  swap(a.lruInsertionPointSpec_ref().value(), b.lruInsertionPointSpec_ref().value());
  swap(a.updateOnRead_ref().value(), b.updateOnRead_ref().value());
  swap(a.tryLockUpdate_ref().value(), b.tryLockUpdate_ref().value());
  swap(a.lruRefreshRatio_ref().value(), b.lruRefreshRatio_ref().value());
  swap(a.__isset, b.__isset);
}

template void MMLruConfig::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MMLruConfig::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MMLruConfig::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MMLruConfig::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MMLruConfig::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MMLruConfig::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MMLruConfig::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MMLruConfig::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::cachelib::serialization

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::cachelib::serialization::MMLruObject>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::facebook::cachelib::serialization::MMLruObject>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace cachelib { namespace serialization {


MMLruObject::MMLruObject(apache::thrift::FragileConstructor, ::facebook::cachelib::serialization::MMLruConfig config__arg, ::std::int64_t evictions__arg, ::std::int64_t insertionPoint__arg, ::std::int64_t tailSize__arg, ::facebook::cachelib::serialization::DListObject lru__arg, ::std::int64_t compressedInsertionPoint__arg) :
    config(std::move(config__arg)),
    __fbthrift_field_evictions(std::move(evictions__arg)),
    insertionPoint(std::move(insertionPoint__arg)),
    tailSize(std::move(tailSize__arg)),
    lru(std::move(lru__arg)),
    compressedInsertionPoint(std::move(compressedInsertionPoint__arg)) {
  __isset.set(folly::index_constant<0>(), true);
}


void MMLruObject::__clear() {
  // clear all fields
  this->config.__clear();
  this->__fbthrift_field_evictions = static_cast<::std::int64_t>(0);
  this->insertionPoint = ::std::int64_t();
  this->tailSize = ::std::int64_t();
  this->lru.__clear();
  this->compressedInsertionPoint = ::std::int64_t();
  __isset = {};
}

bool MMLruObject::operator==(const MMLruObject& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.config_ref() == rhs.config_ref())) {
    return false;
  }
  if (!(lhs.evictions_ref() == rhs.evictions_ref())) {
    return false;
  }
  if (!(lhs.insertionPoint_ref() == rhs.insertionPoint_ref())) {
    return false;
  }
  if (!(lhs.tailSize_ref() == rhs.tailSize_ref())) {
    return false;
  }
  if (!(lhs.lru_ref() == rhs.lru_ref())) {
    return false;
  }
  if (!(lhs.compressedInsertionPoint_ref() == rhs.compressedInsertionPoint_ref())) {
    return false;
  }
  return true;
}

bool MMLruObject::operator<(const MMLruObject& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.config_ref() == rhs.config_ref())) {
    return lhs.config_ref() < rhs.config_ref();
  }
  if (!(lhs.evictions_ref() == rhs.evictions_ref())) {
    return lhs.evictions_ref() < rhs.evictions_ref();
  }
  if (!(lhs.insertionPoint_ref() == rhs.insertionPoint_ref())) {
    return lhs.insertionPoint_ref() < rhs.insertionPoint_ref();
  }
  if (!(lhs.tailSize_ref() == rhs.tailSize_ref())) {
    return lhs.tailSize_ref() < rhs.tailSize_ref();
  }
  if (!(lhs.lru_ref() == rhs.lru_ref())) {
    return lhs.lru_ref() < rhs.lru_ref();
  }
  if (!(lhs.compressedInsertionPoint_ref() == rhs.compressedInsertionPoint_ref())) {
    return lhs.compressedInsertionPoint_ref() < rhs.compressedInsertionPoint_ref();
  }
  return false;
}

const ::facebook::cachelib::serialization::MMLruConfig& MMLruObject::get_config() const& {
  return config;
}

::facebook::cachelib::serialization::MMLruConfig MMLruObject::get_config() && {
  return std::move(config);
}

const ::facebook::cachelib::serialization::DListObject& MMLruObject::get_lru() const& {
  return lru;
}

::facebook::cachelib::serialization::DListObject MMLruObject::get_lru() && {
  return std::move(lru);
}


void swap(MMLruObject& a, MMLruObject& b) {
  using ::std::swap;
  swap(a.config_ref().value(), b.config_ref().value());
  swap(a.evictions_ref().value(), b.evictions_ref().value());
  swap(a.insertionPoint_ref().value(), b.insertionPoint_ref().value());
  swap(a.tailSize_ref().value(), b.tailSize_ref().value());
  swap(a.lru_ref().value(), b.lru_ref().value());
  swap(a.compressedInsertionPoint_ref().value(), b.compressedInsertionPoint_ref().value());
  swap(a.__isset, b.__isset);
}

template void MMLruObject::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MMLruObject::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MMLruObject::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MMLruObject::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MMLruObject::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MMLruObject::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MMLruObject::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MMLruObject::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        MMLruObject,
        ::apache::thrift::type_class::structure,
        ::facebook::cachelib::serialization::MMLruConfig>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        MMLruObject,
        ::apache::thrift::type_class::structure,
        ::facebook::cachelib::serialization::DListObject>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        MMLruObject,
        ::apache::thrift::type_class::structure,
        ::facebook::cachelib::serialization::MMLruConfig>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        MMLruObject,
        ::apache::thrift::type_class::structure,
        ::facebook::cachelib::serialization::DListObject>,
    "inconsistent use of nimble option");

}}} // facebook::cachelib::serialization

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::cachelib::serialization::MMLruCollection>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::facebook::cachelib::serialization::MMLruCollection>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace cachelib { namespace serialization {

MMLruCollection::MMLruCollection(const MMLruCollection&) = default;
MMLruCollection& MMLruCollection::operator=(const MMLruCollection&) = default;
MMLruCollection::MMLruCollection(MMLruCollection&& other) noexcept  :
    pools(std::move(other.pools)) {
}

MMLruCollection& MMLruCollection::operator=(FOLLY_MAYBE_UNUSED MMLruCollection&& other) noexcept {
    this->pools = std::move(other.pools);
    return *this;
}


MMLruCollection::MMLruCollection(apache::thrift::FragileConstructor, ::std::map<::std::int32_t, ::std::map<::std::int32_t, ::facebook::cachelib::serialization::MMLruObject>> pools__arg) :
    pools(std::move(pools__arg)) {
}


void MMLruCollection::__clear() {
  // clear all fields
  this->pools.clear();
}

bool MMLruCollection::operator==(const MMLruCollection& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.pools_ref() == rhs.pools_ref())) {
    return false;
  }
  return true;
}

bool MMLruCollection::operator<(const MMLruCollection& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.pools_ref() == rhs.pools_ref())) {
    return lhs.pools_ref() < rhs.pools_ref();
  }
  return false;
}

const ::std::map<::std::int32_t, ::std::map<::std::int32_t, ::facebook::cachelib::serialization::MMLruObject>>& MMLruCollection::get_pools() const& {
  return pools;
}

::std::map<::std::int32_t, ::std::map<::std::int32_t, ::facebook::cachelib::serialization::MMLruObject>> MMLruCollection::get_pools() && {
  return std::move(pools);
}


void swap(MMLruCollection& a, MMLruCollection& b) {
  using ::std::swap;
  swap(a.pools_ref().value(), b.pools_ref().value());
}

template void MMLruCollection::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MMLruCollection::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MMLruCollection::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MMLruCollection::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MMLruCollection::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MMLruCollection::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MMLruCollection::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MMLruCollection::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        MMLruCollection,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>>,
        ::std::map<::std::int32_t, ::std::map<::std::int32_t, ::facebook::cachelib::serialization::MMLruObject>>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        MMLruCollection,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>>,
        ::std::map<::std::int32_t, ::std::map<::std::int32_t, ::facebook::cachelib::serialization::MMLruObject>>>,
    "inconsistent use of nimble option");

}}} // facebook::cachelib::serialization

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::cachelib::serialization::MM2QConfig>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::facebook::cachelib::serialization::MM2QConfig>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace cachelib { namespace serialization {


MM2QConfig::MM2QConfig(apache::thrift::FragileConstructor, ::std::int32_t lruRefreshTime__arg, bool updateOnWrite__arg, ::std::int32_t hotSizePercent__arg, ::std::int32_t coldSizePercent__arg, bool updateOnRead__arg, bool tryLockUpdate__arg, bool rebalanceOnRecordAccess__arg, double lruRefreshRatio__arg) :
    lruRefreshTime(std::move(lruRefreshTime__arg)),
    updateOnWrite(std::move(updateOnWrite__arg)),
    hotSizePercent(std::move(hotSizePercent__arg)),
    coldSizePercent(std::move(coldSizePercent__arg)),
    __fbthrift_field_updateOnRead(std::move(updateOnRead__arg)),
    __fbthrift_field_tryLockUpdate(std::move(tryLockUpdate__arg)),
    __fbthrift_field_rebalanceOnRecordAccess(std::move(rebalanceOnRecordAccess__arg)),
    __fbthrift_field_lruRefreshRatio(std::move(lruRefreshRatio__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
  __isset.set(folly::index_constant<3>(), true);
}


void MM2QConfig::__clear() {
  // clear all fields
  this->lruRefreshTime = ::std::int32_t();
  this->updateOnWrite = bool();
  this->hotSizePercent = ::std::int32_t();
  this->coldSizePercent = ::std::int32_t();
  this->__fbthrift_field_updateOnRead = static_cast<bool>(true);
  this->__fbthrift_field_tryLockUpdate = static_cast<bool>(false);
  this->__fbthrift_field_rebalanceOnRecordAccess = static_cast<bool>(true);
  this->__fbthrift_field_lruRefreshRatio = static_cast<double>(0);
  __isset = {};
}

bool MM2QConfig::operator==(const MM2QConfig& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.lruRefreshTime_ref() == rhs.lruRefreshTime_ref())) {
    return false;
  }
  if (!(lhs.updateOnWrite_ref() == rhs.updateOnWrite_ref())) {
    return false;
  }
  if (!(lhs.hotSizePercent_ref() == rhs.hotSizePercent_ref())) {
    return false;
  }
  if (!(lhs.coldSizePercent_ref() == rhs.coldSizePercent_ref())) {
    return false;
  }
  if (!(lhs.updateOnRead_ref() == rhs.updateOnRead_ref())) {
    return false;
  }
  if (!(lhs.tryLockUpdate_ref() == rhs.tryLockUpdate_ref())) {
    return false;
  }
  if (!(lhs.rebalanceOnRecordAccess_ref() == rhs.rebalanceOnRecordAccess_ref())) {
    return false;
  }
  if (!(lhs.lruRefreshRatio_ref() == rhs.lruRefreshRatio_ref())) {
    return false;
  }
  return true;
}

bool MM2QConfig::operator<(const MM2QConfig& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.lruRefreshTime_ref() == rhs.lruRefreshTime_ref())) {
    return lhs.lruRefreshTime_ref() < rhs.lruRefreshTime_ref();
  }
  if (!(lhs.updateOnWrite_ref() == rhs.updateOnWrite_ref())) {
    return lhs.updateOnWrite_ref() < rhs.updateOnWrite_ref();
  }
  if (!(lhs.hotSizePercent_ref() == rhs.hotSizePercent_ref())) {
    return lhs.hotSizePercent_ref() < rhs.hotSizePercent_ref();
  }
  if (!(lhs.coldSizePercent_ref() == rhs.coldSizePercent_ref())) {
    return lhs.coldSizePercent_ref() < rhs.coldSizePercent_ref();
  }
  if (!(lhs.updateOnRead_ref() == rhs.updateOnRead_ref())) {
    return lhs.updateOnRead_ref() < rhs.updateOnRead_ref();
  }
  if (!(lhs.tryLockUpdate_ref() == rhs.tryLockUpdate_ref())) {
    return lhs.tryLockUpdate_ref() < rhs.tryLockUpdate_ref();
  }
  if (!(lhs.rebalanceOnRecordAccess_ref() == rhs.rebalanceOnRecordAccess_ref())) {
    return lhs.rebalanceOnRecordAccess_ref() < rhs.rebalanceOnRecordAccess_ref();
  }
  if (!(lhs.lruRefreshRatio_ref() == rhs.lruRefreshRatio_ref())) {
    return lhs.lruRefreshRatio_ref() < rhs.lruRefreshRatio_ref();
  }
  return false;
}


void swap(MM2QConfig& a, MM2QConfig& b) {
  using ::std::swap;
  swap(a.lruRefreshTime_ref().value(), b.lruRefreshTime_ref().value());
  swap(a.updateOnWrite_ref().value(), b.updateOnWrite_ref().value());
  swap(a.hotSizePercent_ref().value(), b.hotSizePercent_ref().value());
  swap(a.coldSizePercent_ref().value(), b.coldSizePercent_ref().value());
  swap(a.updateOnRead_ref().value(), b.updateOnRead_ref().value());
  swap(a.tryLockUpdate_ref().value(), b.tryLockUpdate_ref().value());
  swap(a.rebalanceOnRecordAccess_ref().value(), b.rebalanceOnRecordAccess_ref().value());
  swap(a.lruRefreshRatio_ref().value(), b.lruRefreshRatio_ref().value());
  swap(a.__isset, b.__isset);
}

template void MM2QConfig::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MM2QConfig::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MM2QConfig::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MM2QConfig::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MM2QConfig::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MM2QConfig::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MM2QConfig::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MM2QConfig::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::cachelib::serialization

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::cachelib::serialization::MM2QObject>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::facebook::cachelib::serialization::MM2QObject>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace cachelib { namespace serialization {

MM2QObject::MM2QObject(const MM2QObject&) = default;
MM2QObject& MM2QObject::operator=(const MM2QObject&) = default;
MM2QObject::MM2QObject(MM2QObject&& other) noexcept  :
    config(std::move(other.config)),
    __fbthrift_field_tailTrackingEnabled(std::move(other.__fbthrift_field_tailTrackingEnabled)),
    __fbthrift_field_evictions(std::move(other.__fbthrift_field_evictions)),
    lrus(std::move(other.lrus)),
    __isset(other.__isset) {
}

MM2QObject& MM2QObject::operator=(FOLLY_MAYBE_UNUSED MM2QObject&& other) noexcept {
    this->config = std::move(other.config);
    this->__fbthrift_field_tailTrackingEnabled = std::move(other.__fbthrift_field_tailTrackingEnabled);
    this->__fbthrift_field_evictions = std::move(other.__fbthrift_field_evictions);
    this->lrus = std::move(other.lrus);
    __isset = other.__isset;
    return *this;
}


MM2QObject::MM2QObject(apache::thrift::FragileConstructor, ::facebook::cachelib::serialization::MM2QConfig config__arg, bool tailTrackingEnabled__arg, ::std::int64_t evictions__arg, ::facebook::cachelib::serialization::MultiDListObject lrus__arg) :
    config(std::move(config__arg)),
    __fbthrift_field_tailTrackingEnabled(std::move(tailTrackingEnabled__arg)),
    __fbthrift_field_evictions(std::move(evictions__arg)),
    lrus(std::move(lrus__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
}


void MM2QObject::__clear() {
  // clear all fields
  this->config.__clear();
  this->__fbthrift_field_tailTrackingEnabled = static_cast<bool>(false);
  this->__fbthrift_field_evictions = static_cast<::std::int64_t>(0);
  this->lrus.__clear();
  __isset = {};
}

bool MM2QObject::operator==(const MM2QObject& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.config_ref() == rhs.config_ref())) {
    return false;
  }
  if (!(lhs.tailTrackingEnabled_ref() == rhs.tailTrackingEnabled_ref())) {
    return false;
  }
  if (!(lhs.evictions_ref() == rhs.evictions_ref())) {
    return false;
  }
  if (!(lhs.lrus_ref() == rhs.lrus_ref())) {
    return false;
  }
  return true;
}

bool MM2QObject::operator<(const MM2QObject& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.config_ref() == rhs.config_ref())) {
    return lhs.config_ref() < rhs.config_ref();
  }
  if (!(lhs.tailTrackingEnabled_ref() == rhs.tailTrackingEnabled_ref())) {
    return lhs.tailTrackingEnabled_ref() < rhs.tailTrackingEnabled_ref();
  }
  if (!(lhs.evictions_ref() == rhs.evictions_ref())) {
    return lhs.evictions_ref() < rhs.evictions_ref();
  }
  if (!(lhs.lrus_ref() == rhs.lrus_ref())) {
    return lhs.lrus_ref() < rhs.lrus_ref();
  }
  return false;
}

const ::facebook::cachelib::serialization::MM2QConfig& MM2QObject::get_config() const& {
  return config;
}

::facebook::cachelib::serialization::MM2QConfig MM2QObject::get_config() && {
  return std::move(config);
}

const ::facebook::cachelib::serialization::MultiDListObject& MM2QObject::get_lrus() const& {
  return lrus;
}

::facebook::cachelib::serialization::MultiDListObject MM2QObject::get_lrus() && {
  return std::move(lrus);
}


void swap(MM2QObject& a, MM2QObject& b) {
  using ::std::swap;
  swap(a.config_ref().value(), b.config_ref().value());
  swap(a.tailTrackingEnabled_ref().value(), b.tailTrackingEnabled_ref().value());
  swap(a.evictions_ref().value(), b.evictions_ref().value());
  swap(a.lrus_ref().value(), b.lrus_ref().value());
  swap(a.__isset, b.__isset);
}

template void MM2QObject::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MM2QObject::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MM2QObject::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MM2QObject::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MM2QObject::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MM2QObject::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MM2QObject::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MM2QObject::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        MM2QObject,
        ::apache::thrift::type_class::structure,
        ::facebook::cachelib::serialization::MM2QConfig>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        MM2QObject,
        ::apache::thrift::type_class::structure,
        ::facebook::cachelib::serialization::MultiDListObject>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        MM2QObject,
        ::apache::thrift::type_class::structure,
        ::facebook::cachelib::serialization::MM2QConfig>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        MM2QObject,
        ::apache::thrift::type_class::structure,
        ::facebook::cachelib::serialization::MultiDListObject>,
    "inconsistent use of nimble option");

}}} // facebook::cachelib::serialization

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::cachelib::serialization::MM2QCollection>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::facebook::cachelib::serialization::MM2QCollection>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace cachelib { namespace serialization {

MM2QCollection::MM2QCollection(const MM2QCollection&) = default;
MM2QCollection& MM2QCollection::operator=(const MM2QCollection&) = default;
MM2QCollection::MM2QCollection(MM2QCollection&& other) noexcept  :
    pools(std::move(other.pools)) {
}

MM2QCollection& MM2QCollection::operator=(FOLLY_MAYBE_UNUSED MM2QCollection&& other) noexcept {
    this->pools = std::move(other.pools);
    return *this;
}


MM2QCollection::MM2QCollection(apache::thrift::FragileConstructor, ::std::map<::std::int32_t, ::std::map<::std::int32_t, ::facebook::cachelib::serialization::MM2QObject>> pools__arg) :
    pools(std::move(pools__arg)) {
}


void MM2QCollection::__clear() {
  // clear all fields
  this->pools.clear();
}

bool MM2QCollection::operator==(const MM2QCollection& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.pools_ref() == rhs.pools_ref())) {
    return false;
  }
  return true;
}

bool MM2QCollection::operator<(const MM2QCollection& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.pools_ref() == rhs.pools_ref())) {
    return lhs.pools_ref() < rhs.pools_ref();
  }
  return false;
}

const ::std::map<::std::int32_t, ::std::map<::std::int32_t, ::facebook::cachelib::serialization::MM2QObject>>& MM2QCollection::get_pools() const& {
  return pools;
}

::std::map<::std::int32_t, ::std::map<::std::int32_t, ::facebook::cachelib::serialization::MM2QObject>> MM2QCollection::get_pools() && {
  return std::move(pools);
}


void swap(MM2QCollection& a, MM2QCollection& b) {
  using ::std::swap;
  swap(a.pools_ref().value(), b.pools_ref().value());
}

template void MM2QCollection::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MM2QCollection::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MM2QCollection::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MM2QCollection::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MM2QCollection::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MM2QCollection::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MM2QCollection::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MM2QCollection::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        MM2QCollection,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>>,
        ::std::map<::std::int32_t, ::std::map<::std::int32_t, ::facebook::cachelib::serialization::MM2QObject>>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        MM2QCollection,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>>,
        ::std::map<::std::int32_t, ::std::map<::std::int32_t, ::facebook::cachelib::serialization::MM2QObject>>>,
    "inconsistent use of nimble option");

}}} // facebook::cachelib::serialization

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::cachelib::serialization::MMTinyLFUConfig>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::facebook::cachelib::serialization::MMTinyLFUConfig>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace cachelib { namespace serialization {


MMTinyLFUConfig::MMTinyLFUConfig(apache::thrift::FragileConstructor, ::std::int32_t lruRefreshTime__arg, bool updateOnWrite__arg, ::std::int32_t windowToCacheSizeRatio__arg, ::std::int32_t tinySizePercent__arg, bool updateOnRead__arg, bool tryLockUpdate__arg, double lruRefreshRatio__arg) :
    lruRefreshTime(std::move(lruRefreshTime__arg)),
    updateOnWrite(std::move(updateOnWrite__arg)),
    windowToCacheSizeRatio(std::move(windowToCacheSizeRatio__arg)),
    tinySizePercent(std::move(tinySizePercent__arg)),
    __fbthrift_field_updateOnRead(std::move(updateOnRead__arg)),
    __fbthrift_field_tryLockUpdate(std::move(tryLockUpdate__arg)),
    __fbthrift_field_lruRefreshRatio(std::move(lruRefreshRatio__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
}


void MMTinyLFUConfig::__clear() {
  // clear all fields
  this->lruRefreshTime = ::std::int32_t();
  this->updateOnWrite = bool();
  this->windowToCacheSizeRatio = ::std::int32_t();
  this->tinySizePercent = ::std::int32_t();
  this->__fbthrift_field_updateOnRead = static_cast<bool>(true);
  this->__fbthrift_field_tryLockUpdate = static_cast<bool>(false);
  this->__fbthrift_field_lruRefreshRatio = static_cast<double>(0);
  __isset = {};
}

bool MMTinyLFUConfig::operator==(const MMTinyLFUConfig& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.lruRefreshTime_ref() == rhs.lruRefreshTime_ref())) {
    return false;
  }
  if (!(lhs.updateOnWrite_ref() == rhs.updateOnWrite_ref())) {
    return false;
  }
  if (!(lhs.windowToCacheSizeRatio_ref() == rhs.windowToCacheSizeRatio_ref())) {
    return false;
  }
  if (!(lhs.tinySizePercent_ref() == rhs.tinySizePercent_ref())) {
    return false;
  }
  if (!(lhs.updateOnRead_ref() == rhs.updateOnRead_ref())) {
    return false;
  }
  if (!(lhs.tryLockUpdate_ref() == rhs.tryLockUpdate_ref())) {
    return false;
  }
  if (!(lhs.lruRefreshRatio_ref() == rhs.lruRefreshRatio_ref())) {
    return false;
  }
  return true;
}

bool MMTinyLFUConfig::operator<(const MMTinyLFUConfig& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.lruRefreshTime_ref() == rhs.lruRefreshTime_ref())) {
    return lhs.lruRefreshTime_ref() < rhs.lruRefreshTime_ref();
  }
  if (!(lhs.updateOnWrite_ref() == rhs.updateOnWrite_ref())) {
    return lhs.updateOnWrite_ref() < rhs.updateOnWrite_ref();
  }
  if (!(lhs.windowToCacheSizeRatio_ref() == rhs.windowToCacheSizeRatio_ref())) {
    return lhs.windowToCacheSizeRatio_ref() < rhs.windowToCacheSizeRatio_ref();
  }
  if (!(lhs.tinySizePercent_ref() == rhs.tinySizePercent_ref())) {
    return lhs.tinySizePercent_ref() < rhs.tinySizePercent_ref();
  }
  if (!(lhs.updateOnRead_ref() == rhs.updateOnRead_ref())) {
    return lhs.updateOnRead_ref() < rhs.updateOnRead_ref();
  }
  if (!(lhs.tryLockUpdate_ref() == rhs.tryLockUpdate_ref())) {
    return lhs.tryLockUpdate_ref() < rhs.tryLockUpdate_ref();
  }
  if (!(lhs.lruRefreshRatio_ref() == rhs.lruRefreshRatio_ref())) {
    return lhs.lruRefreshRatio_ref() < rhs.lruRefreshRatio_ref();
  }
  return false;
}


void swap(MMTinyLFUConfig& a, MMTinyLFUConfig& b) {
  using ::std::swap;
  swap(a.lruRefreshTime_ref().value(), b.lruRefreshTime_ref().value());
  swap(a.updateOnWrite_ref().value(), b.updateOnWrite_ref().value());
  swap(a.windowToCacheSizeRatio_ref().value(), b.windowToCacheSizeRatio_ref().value());
  swap(a.tinySizePercent_ref().value(), b.tinySizePercent_ref().value());
  swap(a.updateOnRead_ref().value(), b.updateOnRead_ref().value());
  swap(a.tryLockUpdate_ref().value(), b.tryLockUpdate_ref().value());
  swap(a.lruRefreshRatio_ref().value(), b.lruRefreshRatio_ref().value());
  swap(a.__isset, b.__isset);
}

template void MMTinyLFUConfig::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MMTinyLFUConfig::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MMTinyLFUConfig::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MMTinyLFUConfig::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MMTinyLFUConfig::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MMTinyLFUConfig::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MMTinyLFUConfig::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MMTinyLFUConfig::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::cachelib::serialization

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::cachelib::serialization::MMTinyLFUObject>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::facebook::cachelib::serialization::MMTinyLFUObject>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace cachelib { namespace serialization {

MMTinyLFUObject::MMTinyLFUObject(const MMTinyLFUObject&) = default;
MMTinyLFUObject& MMTinyLFUObject::operator=(const MMTinyLFUObject&) = default;
MMTinyLFUObject::MMTinyLFUObject(MMTinyLFUObject&& other) noexcept  :
    config(std::move(other.config)),
    __fbthrift_field_evictions(std::move(other.__fbthrift_field_evictions)),
    lrus(std::move(other.lrus)),
    __isset(other.__isset) {
}

MMTinyLFUObject& MMTinyLFUObject::operator=(FOLLY_MAYBE_UNUSED MMTinyLFUObject&& other) noexcept {
    this->config = std::move(other.config);
    this->__fbthrift_field_evictions = std::move(other.__fbthrift_field_evictions);
    this->lrus = std::move(other.lrus);
    __isset = other.__isset;
    return *this;
}


MMTinyLFUObject::MMTinyLFUObject(apache::thrift::FragileConstructor, ::facebook::cachelib::serialization::MMTinyLFUConfig config__arg, ::std::int64_t evictions__arg, ::facebook::cachelib::serialization::MultiDListObject lrus__arg) :
    config(std::move(config__arg)),
    __fbthrift_field_evictions(std::move(evictions__arg)),
    lrus(std::move(lrus__arg)) {
  __isset.set(folly::index_constant<0>(), true);
}


void MMTinyLFUObject::__clear() {
  // clear all fields
  this->config.__clear();
  this->__fbthrift_field_evictions = static_cast<::std::int64_t>(0);
  this->lrus.__clear();
  __isset = {};
}

bool MMTinyLFUObject::operator==(const MMTinyLFUObject& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.config_ref() == rhs.config_ref())) {
    return false;
  }
  if (!(lhs.evictions_ref() == rhs.evictions_ref())) {
    return false;
  }
  if (!(lhs.lrus_ref() == rhs.lrus_ref())) {
    return false;
  }
  return true;
}

bool MMTinyLFUObject::operator<(const MMTinyLFUObject& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.config_ref() == rhs.config_ref())) {
    return lhs.config_ref() < rhs.config_ref();
  }
  if (!(lhs.evictions_ref() == rhs.evictions_ref())) {
    return lhs.evictions_ref() < rhs.evictions_ref();
  }
  if (!(lhs.lrus_ref() == rhs.lrus_ref())) {
    return lhs.lrus_ref() < rhs.lrus_ref();
  }
  return false;
}

const ::facebook::cachelib::serialization::MMTinyLFUConfig& MMTinyLFUObject::get_config() const& {
  return config;
}

::facebook::cachelib::serialization::MMTinyLFUConfig MMTinyLFUObject::get_config() && {
  return std::move(config);
}

const ::facebook::cachelib::serialization::MultiDListObject& MMTinyLFUObject::get_lrus() const& {
  return lrus;
}

::facebook::cachelib::serialization::MultiDListObject MMTinyLFUObject::get_lrus() && {
  return std::move(lrus);
}


void swap(MMTinyLFUObject& a, MMTinyLFUObject& b) {
  using ::std::swap;
  swap(a.config_ref().value(), b.config_ref().value());
  swap(a.evictions_ref().value(), b.evictions_ref().value());
  swap(a.lrus_ref().value(), b.lrus_ref().value());
  swap(a.__isset, b.__isset);
}

template void MMTinyLFUObject::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MMTinyLFUObject::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MMTinyLFUObject::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MMTinyLFUObject::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MMTinyLFUObject::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MMTinyLFUObject::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MMTinyLFUObject::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MMTinyLFUObject::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        MMTinyLFUObject,
        ::apache::thrift::type_class::structure,
        ::facebook::cachelib::serialization::MMTinyLFUConfig>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        MMTinyLFUObject,
        ::apache::thrift::type_class::structure,
        ::facebook::cachelib::serialization::MultiDListObject>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        MMTinyLFUObject,
        ::apache::thrift::type_class::structure,
        ::facebook::cachelib::serialization::MMTinyLFUConfig>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        MMTinyLFUObject,
        ::apache::thrift::type_class::structure,
        ::facebook::cachelib::serialization::MultiDListObject>,
    "inconsistent use of nimble option");

}}} // facebook::cachelib::serialization

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::cachelib::serialization::MMTinyLFUCollection>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::facebook::cachelib::serialization::MMTinyLFUCollection>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace cachelib { namespace serialization {

MMTinyLFUCollection::MMTinyLFUCollection(const MMTinyLFUCollection&) = default;
MMTinyLFUCollection& MMTinyLFUCollection::operator=(const MMTinyLFUCollection&) = default;
MMTinyLFUCollection::MMTinyLFUCollection(MMTinyLFUCollection&& other) noexcept  :
    pools(std::move(other.pools)) {
}

MMTinyLFUCollection& MMTinyLFUCollection::operator=(FOLLY_MAYBE_UNUSED MMTinyLFUCollection&& other) noexcept {
    this->pools = std::move(other.pools);
    return *this;
}


MMTinyLFUCollection::MMTinyLFUCollection(apache::thrift::FragileConstructor, ::std::map<::std::int32_t, ::std::map<::std::int32_t, ::facebook::cachelib::serialization::MMTinyLFUObject>> pools__arg) :
    pools(std::move(pools__arg)) {
}


void MMTinyLFUCollection::__clear() {
  // clear all fields
  this->pools.clear();
}

bool MMTinyLFUCollection::operator==(const MMTinyLFUCollection& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.pools_ref() == rhs.pools_ref())) {
    return false;
  }
  return true;
}

bool MMTinyLFUCollection::operator<(const MMTinyLFUCollection& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.pools_ref() == rhs.pools_ref())) {
    return lhs.pools_ref() < rhs.pools_ref();
  }
  return false;
}

const ::std::map<::std::int32_t, ::std::map<::std::int32_t, ::facebook::cachelib::serialization::MMTinyLFUObject>>& MMTinyLFUCollection::get_pools() const& {
  return pools;
}

::std::map<::std::int32_t, ::std::map<::std::int32_t, ::facebook::cachelib::serialization::MMTinyLFUObject>> MMTinyLFUCollection::get_pools() && {
  return std::move(pools);
}


void swap(MMTinyLFUCollection& a, MMTinyLFUCollection& b) {
  using ::std::swap;
  swap(a.pools_ref().value(), b.pools_ref().value());
}

template void MMTinyLFUCollection::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MMTinyLFUCollection::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MMTinyLFUCollection::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MMTinyLFUCollection::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MMTinyLFUCollection::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MMTinyLFUCollection::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MMTinyLFUCollection::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MMTinyLFUCollection::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        MMTinyLFUCollection,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>>,
        ::std::map<::std::int32_t, ::std::map<::std::int32_t, ::facebook::cachelib::serialization::MMTinyLFUObject>>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        MMTinyLFUCollection,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>>,
        ::std::map<::std::int32_t, ::std::map<::std::int32_t, ::facebook::cachelib::serialization::MMTinyLFUObject>>>,
    "inconsistent use of nimble option");

}}} // facebook::cachelib::serialization

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::cachelib::serialization::ChainedHashTableObject>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::facebook::cachelib::serialization::ChainedHashTableObject>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace cachelib { namespace serialization {


ChainedHashTableObject::ChainedHashTableObject(apache::thrift::FragileConstructor, ::std::int32_t bucketsPower__arg, ::std::int32_t locksPower__arg, ::std::int64_t numKeys__arg, ::std::int32_t hasherMagicId__arg) :
    bucketsPower(std::move(bucketsPower__arg)),
    locksPower(std::move(locksPower__arg)),
    __fbthrift_field_numKeys(std::move(numKeys__arg)),
    __fbthrift_field_hasherMagicId(std::move(hasherMagicId__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
}


void ChainedHashTableObject::__clear() {
  // clear all fields
  this->bucketsPower = ::std::int32_t();
  this->locksPower = ::std::int32_t();
  this->__fbthrift_field_numKeys = ::std::int64_t();
  this->__fbthrift_field_hasherMagicId = static_cast<::std::int32_t>(0);
  __isset = {};
}

bool ChainedHashTableObject::operator==(const ChainedHashTableObject& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.bucketsPower_ref() == rhs.bucketsPower_ref())) {
    return false;
  }
  if (!(lhs.locksPower_ref() == rhs.locksPower_ref())) {
    return false;
  }
  if (!(lhs.numKeys_ref() == rhs.numKeys_ref())) {
    return false;
  }
  if (!(lhs.hasherMagicId_ref() == rhs.hasherMagicId_ref())) {
    return false;
  }
  return true;
}

bool ChainedHashTableObject::operator<(const ChainedHashTableObject& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.bucketsPower_ref() == rhs.bucketsPower_ref())) {
    return lhs.bucketsPower_ref() < rhs.bucketsPower_ref();
  }
  if (!(lhs.locksPower_ref() == rhs.locksPower_ref())) {
    return lhs.locksPower_ref() < rhs.locksPower_ref();
  }
  if (!(lhs.numKeys_ref() == rhs.numKeys_ref())) {
    return lhs.numKeys_ref() < rhs.numKeys_ref();
  }
  if (!(lhs.hasherMagicId_ref() == rhs.hasherMagicId_ref())) {
    return lhs.hasherMagicId_ref() < rhs.hasherMagicId_ref();
  }
  return false;
}


void swap(ChainedHashTableObject& a, ChainedHashTableObject& b) {
  using ::std::swap;
  swap(a.bucketsPower_ref().value(), b.bucketsPower_ref().value());
  swap(a.locksPower_ref().value(), b.locksPower_ref().value());
  swap(a.numKeys_ref().value(), b.numKeys_ref().value());
  swap(a.hasherMagicId_ref().value(), b.hasherMagicId_ref().value());
  swap(a.__isset, b.__isset);
}

template void ChainedHashTableObject::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ChainedHashTableObject::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ChainedHashTableObject::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ChainedHashTableObject::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ChainedHashTableObject::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ChainedHashTableObject::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ChainedHashTableObject::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ChainedHashTableObject::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::cachelib::serialization

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::cachelib::serialization::MMTTLBucketObject>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::facebook::cachelib::serialization::MMTTLBucketObject>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace cachelib { namespace serialization {


MMTTLBucketObject::MMTTLBucketObject(apache::thrift::FragileConstructor, ::std::int64_t expirationTime__arg, ::std::int64_t creationTime__arg, ::facebook::cachelib::serialization::DListObject dList__arg) :
    __fbthrift_field_expirationTime(std::move(expirationTime__arg)),
    __fbthrift_field_creationTime(std::move(creationTime__arg)),
    dList(std::move(dList__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
}


void MMTTLBucketObject::__clear() {
  // clear all fields
  this->__fbthrift_field_expirationTime = ::std::int64_t();
  this->__fbthrift_field_creationTime = ::std::int64_t();
  this->dList.__clear();
  __isset = {};
}

bool MMTTLBucketObject::operator==(const MMTTLBucketObject& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.expirationTime_ref() == rhs.expirationTime_ref())) {
    return false;
  }
  if (!(lhs.creationTime_ref() == rhs.creationTime_ref())) {
    return false;
  }
  if (!(lhs.dList_ref() == rhs.dList_ref())) {
    return false;
  }
  return true;
}

bool MMTTLBucketObject::operator<(const MMTTLBucketObject& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.expirationTime_ref() == rhs.expirationTime_ref())) {
    return lhs.expirationTime_ref() < rhs.expirationTime_ref();
  }
  if (!(lhs.creationTime_ref() == rhs.creationTime_ref())) {
    return lhs.creationTime_ref() < rhs.creationTime_ref();
  }
  if (!(lhs.dList_ref() == rhs.dList_ref())) {
    return lhs.dList_ref() < rhs.dList_ref();
  }
  return false;
}

const ::facebook::cachelib::serialization::DListObject& MMTTLBucketObject::get_dList() const& {
  return dList;
}

::facebook::cachelib::serialization::DListObject MMTTLBucketObject::get_dList() && {
  return std::move(dList);
}


void swap(MMTTLBucketObject& a, MMTTLBucketObject& b) {
  using ::std::swap;
  swap(a.expirationTime_ref().value(), b.expirationTime_ref().value());
  swap(a.creationTime_ref().value(), b.creationTime_ref().value());
  swap(a.dList_ref().value(), b.dList_ref().value());
  swap(a.__isset, b.__isset);
}

template void MMTTLBucketObject::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MMTTLBucketObject::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MMTTLBucketObject::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MMTTLBucketObject::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MMTTLBucketObject::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MMTTLBucketObject::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MMTTLBucketObject::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MMTTLBucketObject::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        MMTTLBucketObject,
        ::apache::thrift::type_class::structure,
        ::facebook::cachelib::serialization::DListObject>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        MMTTLBucketObject,
        ::apache::thrift::type_class::structure,
        ::facebook::cachelib::serialization::DListObject>,
    "inconsistent use of nimble option");

}}} // facebook::cachelib::serialization

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::cachelib::serialization::TTLBucketCollection>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::facebook::cachelib::serialization::TTLBucketCollection>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace cachelib { namespace serialization {

TTLBucketCollection::TTLBucketCollection(const TTLBucketCollection&) = default;
TTLBucketCollection& TTLBucketCollection::operator=(const TTLBucketCollection&) = default;
TTLBucketCollection::TTLBucketCollection(TTLBucketCollection&& other) noexcept  :
    buckets(std::move(other.buckets)),
    __fbthrift_field_minEpoch(std::move(other.__fbthrift_field_minEpoch)),
    __fbthrift_field_maxTTL(std::move(other.__fbthrift_field_maxTTL)),
    __fbthrift_field_interval(std::move(other.__fbthrift_field_interval)),
    __isset(other.__isset) {
}

TTLBucketCollection& TTLBucketCollection::operator=(FOLLY_MAYBE_UNUSED TTLBucketCollection&& other) noexcept {
    this->buckets = std::move(other.buckets);
    this->__fbthrift_field_minEpoch = std::move(other.__fbthrift_field_minEpoch);
    this->__fbthrift_field_maxTTL = std::move(other.__fbthrift_field_maxTTL);
    this->__fbthrift_field_interval = std::move(other.__fbthrift_field_interval);
    __isset = other.__isset;
    return *this;
}


TTLBucketCollection::TTLBucketCollection(apache::thrift::FragileConstructor, ::std::map<::std::int64_t, ::facebook::cachelib::serialization::MMTTLBucketObject> buckets__arg, ::std::int64_t minEpoch__arg, ::std::int64_t maxTTL__arg, ::std::int64_t interval__arg) :
    buckets(std::move(buckets__arg)),
    __fbthrift_field_minEpoch(std::move(minEpoch__arg)),
    __fbthrift_field_maxTTL(std::move(maxTTL__arg)),
    __fbthrift_field_interval(std::move(interval__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
}


void TTLBucketCollection::__clear() {
  // clear all fields
  this->buckets.clear();
  this->__fbthrift_field_minEpoch = static_cast<::std::int64_t>(0);
  this->__fbthrift_field_maxTTL = static_cast<::std::int64_t>(0);
  this->__fbthrift_field_interval = static_cast<::std::int64_t>(0);
  __isset = {};
}

bool TTLBucketCollection::operator==(const TTLBucketCollection& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.buckets_ref() == rhs.buckets_ref())) {
    return false;
  }
  if (!(lhs.minEpoch_ref() == rhs.minEpoch_ref())) {
    return false;
  }
  if (!(lhs.maxTTL_ref() == rhs.maxTTL_ref())) {
    return false;
  }
  if (!(lhs.interval_ref() == rhs.interval_ref())) {
    return false;
  }
  return true;
}

bool TTLBucketCollection::operator<(const TTLBucketCollection& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.buckets_ref() == rhs.buckets_ref())) {
    return lhs.buckets_ref() < rhs.buckets_ref();
  }
  if (!(lhs.minEpoch_ref() == rhs.minEpoch_ref())) {
    return lhs.minEpoch_ref() < rhs.minEpoch_ref();
  }
  if (!(lhs.maxTTL_ref() == rhs.maxTTL_ref())) {
    return lhs.maxTTL_ref() < rhs.maxTTL_ref();
  }
  if (!(lhs.interval_ref() == rhs.interval_ref())) {
    return lhs.interval_ref() < rhs.interval_ref();
  }
  return false;
}

const ::std::map<::std::int64_t, ::facebook::cachelib::serialization::MMTTLBucketObject>& TTLBucketCollection::get_buckets() const& {
  return buckets;
}

::std::map<::std::int64_t, ::facebook::cachelib::serialization::MMTTLBucketObject> TTLBucketCollection::get_buckets() && {
  return std::move(buckets);
}


void swap(TTLBucketCollection& a, TTLBucketCollection& b) {
  using ::std::swap;
  swap(a.buckets_ref().value(), b.buckets_ref().value());
  swap(a.minEpoch_ref().value(), b.minEpoch_ref().value());
  swap(a.maxTTL_ref().value(), b.maxTTL_ref().value());
  swap(a.interval_ref().value(), b.interval_ref().value());
  swap(a.__isset, b.__isset);
}

template void TTLBucketCollection::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t TTLBucketCollection::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t TTLBucketCollection::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t TTLBucketCollection::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void TTLBucketCollection::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t TTLBucketCollection::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t TTLBucketCollection::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t TTLBucketCollection::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        TTLBucketCollection,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>,
        ::std::map<::std::int64_t, ::facebook::cachelib::serialization::MMTTLBucketObject>>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        TTLBucketCollection,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>,
        ::std::map<::std::int64_t, ::facebook::cachelib::serialization::MMTTLBucketObject>>,
    "inconsistent use of nimble option");

}}} // facebook::cachelib::serialization

namespace facebook { namespace cachelib { namespace serialization { namespace {
FOLLY_MAYBE_UNUSED FOLLY_ERASE void validateAdapters() {
}
}}}} // facebook::cachelib::serialization
