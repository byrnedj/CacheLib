/**
 * Autogenerated by Thrift for objects.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */
#pragma once

#include <thrift/lib/cpp2/visitation/visit_by_thrift_field_metadata.h>
#include "objects_metadata.h"

namespace apache {
namespace thrift {
namespace detail {

template <>
struct VisitByFieldId<::facebook::cachelib::serialization::CacheAllocatorMetadata> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, int32_t fieldId, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).allocatorVersion_ref());
    case 2:
      return f(1, static_cast<T&&>(t).cacheCreationTime_ref());
    case 3:
      return f(2, static_cast<T&&>(t).accessType_ref());
    case 4:
      return f(3, static_cast<T&&>(t).mmType_ref());
    case 5:
      return f(4, static_cast<T&&>(t).fragmentationSize_ref());
    case 6:
      return f(5, static_cast<T&&>(t).compactCachePools_ref());
    case 7:
      return f(6, static_cast<T&&>(t).numPermanentItems_ref());
    case 8:
      return f(7, static_cast<T&&>(t).numChainedParentItems_ref());
    case 9:
      return f(8, static_cast<T&&>(t).numChainedChildItems_ref());
    case 10:
      return f(9, static_cast<T&&>(t).ramFormatVersion_ref());
    case 11:
      return f(10, static_cast<T&&>(t).numAbortedSlabReleases_ref());
    default:
      throwInvalidThriftId(fieldId, "::facebook::cachelib::serialization::CacheAllocatorMetadata");
    }
  }
};

template <>
struct VisitByFieldId<::facebook::cachelib::serialization::NvmCacheMetadata> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, int32_t fieldId, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).nvmFormatVersion_ref());
    case 2:
      return f(1, static_cast<T&&>(t).creationTime_ref());
    case 3:
      return f(2, static_cast<T&&>(t).safeShutDown_ref());
    case 4:
      return f(3, static_cast<T&&>(t).encryptionEnabled_ref());
    case 5:
      return f(4, static_cast<T&&>(t).truncateAllocSize_ref());
    default:
      throwInvalidThriftId(fieldId, "::facebook::cachelib::serialization::NvmCacheMetadata");
    }
  }
};

template <>
struct VisitByFieldId<::facebook::cachelib::serialization::CompactCacheMetadataObject> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, int32_t fieldId, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).keySize_ref());
    case 2:
      return f(1, static_cast<T&&>(t).valueSize_ref());
    default:
      throwInvalidThriftId(fieldId, "::facebook::cachelib::serialization::CompactCacheMetadataObject");
    }
  }
};

template <>
struct VisitByFieldId<::facebook::cachelib::serialization::CompactCacheAllocatorObject> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, int32_t fieldId, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).chunks_ref());
    case 2:
      return f(1, static_cast<T&&>(t).ccMetadata_ref());
    default:
      throwInvalidThriftId(fieldId, "::facebook::cachelib::serialization::CompactCacheAllocatorObject");
    }
  }
};

template <>
struct VisitByFieldId<::facebook::cachelib::serialization::CompactCacheAllocatorManagerObject> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, int32_t fieldId, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).allocators_ref());
    default:
      throwInvalidThriftId(fieldId, "::facebook::cachelib::serialization::CompactCacheAllocatorManagerObject");
    }
  }
};

template <>
struct VisitByFieldId<::facebook::cachelib::serialization::MMLruConfig> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, int32_t fieldId, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).lruRefreshTime_ref());
    case 2:
      return f(1, static_cast<T&&>(t).updateOnWrite_ref());
    case 3:
      return f(2, static_cast<T&&>(t).lruInsertionPointSpec_ref());
    case 4:
      return f(3, static_cast<T&&>(t).updateOnRead_ref());
    case 5:
      return f(4, static_cast<T&&>(t).tryLockUpdate_ref());
    case 6:
      return f(5, static_cast<T&&>(t).lruRefreshRatio_ref());
    default:
      throwInvalidThriftId(fieldId, "::facebook::cachelib::serialization::MMLruConfig");
    }
  }
};

template <>
struct VisitByFieldId<::facebook::cachelib::serialization::MMLruObject> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, int32_t fieldId, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).config_ref());
    case 5:
      return f(1, static_cast<T&&>(t).evictions_ref());
    case 6:
      return f(2, static_cast<T&&>(t).insertionPoint_ref());
    case 7:
      return f(3, static_cast<T&&>(t).tailSize_ref());
    case 8:
      return f(4, static_cast<T&&>(t).lru_ref());
    case 9:
      return f(5, static_cast<T&&>(t).compressedInsertionPoint_ref());
    default:
      throwInvalidThriftId(fieldId, "::facebook::cachelib::serialization::MMLruObject");
    }
  }
};

template <>
struct VisitByFieldId<::facebook::cachelib::serialization::MMLruCollection> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, int32_t fieldId, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).pools_ref());
    default:
      throwInvalidThriftId(fieldId, "::facebook::cachelib::serialization::MMLruCollection");
    }
  }
};

template <>
struct VisitByFieldId<::facebook::cachelib::serialization::MM2QConfig> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, int32_t fieldId, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).lruRefreshTime_ref());
    case 2:
      return f(1, static_cast<T&&>(t).updateOnWrite_ref());
    case 3:
      return f(2, static_cast<T&&>(t).hotSizePercent_ref());
    case 4:
      return f(3, static_cast<T&&>(t).coldSizePercent_ref());
    case 5:
      return f(4, static_cast<T&&>(t).updateOnRead_ref());
    case 6:
      return f(5, static_cast<T&&>(t).tryLockUpdate_ref());
    case 7:
      return f(6, static_cast<T&&>(t).rebalanceOnRecordAccess_ref());
    case 8:
      return f(7, static_cast<T&&>(t).lruRefreshRatio_ref());
    default:
      throwInvalidThriftId(fieldId, "::facebook::cachelib::serialization::MM2QConfig");
    }
  }
};

template <>
struct VisitByFieldId<::facebook::cachelib::serialization::MM2QObject> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, int32_t fieldId, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).config_ref());
    case 13:
      return f(1, static_cast<T&&>(t).tailTrackingEnabled_ref());
    case 11:
      return f(2, static_cast<T&&>(t).evictions_ref());
    case 12:
      return f(3, static_cast<T&&>(t).lrus_ref());
    default:
      throwInvalidThriftId(fieldId, "::facebook::cachelib::serialization::MM2QObject");
    }
  }
};

template <>
struct VisitByFieldId<::facebook::cachelib::serialization::MM2QCollection> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, int32_t fieldId, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).pools_ref());
    default:
      throwInvalidThriftId(fieldId, "::facebook::cachelib::serialization::MM2QCollection");
    }
  }
};

template <>
struct VisitByFieldId<::facebook::cachelib::serialization::MMTinyLFUConfig> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, int32_t fieldId, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).lruRefreshTime_ref());
    case 2:
      return f(1, static_cast<T&&>(t).updateOnWrite_ref());
    case 3:
      return f(2, static_cast<T&&>(t).windowToCacheSizeRatio_ref());
    case 4:
      return f(3, static_cast<T&&>(t).tinySizePercent_ref());
    case 5:
      return f(4, static_cast<T&&>(t).updateOnRead_ref());
    case 6:
      return f(5, static_cast<T&&>(t).tryLockUpdate_ref());
    case 7:
      return f(6, static_cast<T&&>(t).lruRefreshRatio_ref());
    default:
      throwInvalidThriftId(fieldId, "::facebook::cachelib::serialization::MMTinyLFUConfig");
    }
  }
};

template <>
struct VisitByFieldId<::facebook::cachelib::serialization::MMTinyLFUObject> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, int32_t fieldId, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).config_ref());
    case 2:
      return f(1, static_cast<T&&>(t).evictions_ref());
    case 3:
      return f(2, static_cast<T&&>(t).lrus_ref());
    default:
      throwInvalidThriftId(fieldId, "::facebook::cachelib::serialization::MMTinyLFUObject");
    }
  }
};

template <>
struct VisitByFieldId<::facebook::cachelib::serialization::MMTinyLFUCollection> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, int32_t fieldId, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).pools_ref());
    default:
      throwInvalidThriftId(fieldId, "::facebook::cachelib::serialization::MMTinyLFUCollection");
    }
  }
};

template <>
struct VisitByFieldId<::facebook::cachelib::serialization::ChainedHashTableObject> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, int32_t fieldId, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).bucketsPower_ref());
    case 2:
      return f(1, static_cast<T&&>(t).locksPower_ref());
    case 3:
      return f(2, static_cast<T&&>(t).numKeys_ref());
    case 4:
      return f(3, static_cast<T&&>(t).hasherMagicId_ref());
    default:
      throwInvalidThriftId(fieldId, "::facebook::cachelib::serialization::ChainedHashTableObject");
    }
  }
};

template <>
struct VisitByFieldId<::facebook::cachelib::serialization::MMTTLBucketObject> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, int32_t fieldId, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (fieldId) {
    case 4:
      return f(0, static_cast<T&&>(t).expirationTime_ref());
    case 5:
      return f(1, static_cast<T&&>(t).creationTime_ref());
    case 6:
      return f(2, static_cast<T&&>(t).dList_ref());
    default:
      throwInvalidThriftId(fieldId, "::facebook::cachelib::serialization::MMTTLBucketObject");
    }
  }
};

template <>
struct VisitByFieldId<::facebook::cachelib::serialization::TTLBucketCollection> {
  template <typename F, typename T>
  void operator()(FOLLY_MAYBE_UNUSED F&& f, int32_t fieldId, FOLLY_MAYBE_UNUSED T&& t) const {
    switch (fieldId) {
    case 1:
      return f(0, static_cast<T&&>(t).buckets_ref());
    case 2:
      return f(1, static_cast<T&&>(t).minEpoch_ref());
    case 3:
      return f(2, static_cast<T&&>(t).maxTTL_ref());
    case 4:
      return f(3, static_cast<T&&>(t).interval_ref());
    default:
      throwInvalidThriftId(fieldId, "::facebook::cachelib::serialization::TTLBucketCollection");
    }
  }
};
} // namespace detail
} // namespace thrift
} // namespace apache
