/**
 * Autogenerated by Thrift for BloomFilter.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */
#include "BloomFilter_types.h"
#include "BloomFilter_types.tcc"

#include <thrift/lib/cpp2/gen/module_types_cpp.h>

#include "BloomFilter_data.h"


namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::cachelib::serialization::BloomFilterPersistentData>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::facebook::cachelib::serialization::BloomFilterPersistentData>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace cachelib { namespace serialization {

BloomFilterPersistentData::BloomFilterPersistentData(const BloomFilterPersistentData&) = default;
BloomFilterPersistentData& BloomFilterPersistentData::operator=(const BloomFilterPersistentData&) = default;
BloomFilterPersistentData::BloomFilterPersistentData() :
      numFilters(static_cast<::std::int32_t>(0)),
      hashTableBitSize(static_cast<::std::int64_t>(0)),
      filterByteSize(static_cast<::std::int64_t>(0)),
      fragmentSize(static_cast<::std::int32_t>(0)) {
}


BloomFilterPersistentData::~BloomFilterPersistentData() {}

BloomFilterPersistentData::BloomFilterPersistentData(BloomFilterPersistentData&& other) noexcept  :
    numFilters(std::move(other.numFilters)),
    hashTableBitSize(std::move(other.hashTableBitSize)),
    filterByteSize(std::move(other.filterByteSize)),
    fragmentSize(std::move(other.fragmentSize)),
    seeds(std::move(other.seeds)) {
}

BloomFilterPersistentData& BloomFilterPersistentData::operator=(FOLLY_MAYBE_UNUSED BloomFilterPersistentData&& other) noexcept {
    this->numFilters = std::move(other.numFilters);
    this->hashTableBitSize = std::move(other.hashTableBitSize);
    this->filterByteSize = std::move(other.filterByteSize);
    this->fragmentSize = std::move(other.fragmentSize);
    this->seeds = std::move(other.seeds);
    return *this;
}


BloomFilterPersistentData::BloomFilterPersistentData(apache::thrift::FragileConstructor, ::std::int32_t numFilters__arg, ::std::int64_t hashTableBitSize__arg, ::std::int64_t filterByteSize__arg, ::std::int32_t fragmentSize__arg, ::std::vector<::std::int64_t> seeds__arg) :
    numFilters(std::move(numFilters__arg)),
    hashTableBitSize(std::move(hashTableBitSize__arg)),
    filterByteSize(std::move(filterByteSize__arg)),
    fragmentSize(std::move(fragmentSize__arg)),
    seeds(std::move(seeds__arg)) {
}


void BloomFilterPersistentData::__clear() {
  // clear all fields
  this->numFilters = static_cast<::std::int32_t>(0);
  this->hashTableBitSize = static_cast<::std::int64_t>(0);
  this->filterByteSize = static_cast<::std::int64_t>(0);
  this->fragmentSize = static_cast<::std::int32_t>(0);
  this->seeds.clear();
}

bool BloomFilterPersistentData::operator==(const BloomFilterPersistentData& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.numFilters_ref() == rhs.numFilters_ref())) {
    return false;
  }
  if (!(lhs.hashTableBitSize_ref() == rhs.hashTableBitSize_ref())) {
    return false;
  }
  if (!(lhs.filterByteSize_ref() == rhs.filterByteSize_ref())) {
    return false;
  }
  if (!(lhs.fragmentSize_ref() == rhs.fragmentSize_ref())) {
    return false;
  }
  if (!(lhs.seeds_ref() == rhs.seeds_ref())) {
    return false;
  }
  return true;
}

bool BloomFilterPersistentData::operator<(const BloomFilterPersistentData& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.numFilters_ref() == rhs.numFilters_ref())) {
    return lhs.numFilters_ref() < rhs.numFilters_ref();
  }
  if (!(lhs.hashTableBitSize_ref() == rhs.hashTableBitSize_ref())) {
    return lhs.hashTableBitSize_ref() < rhs.hashTableBitSize_ref();
  }
  if (!(lhs.filterByteSize_ref() == rhs.filterByteSize_ref())) {
    return lhs.filterByteSize_ref() < rhs.filterByteSize_ref();
  }
  if (!(lhs.fragmentSize_ref() == rhs.fragmentSize_ref())) {
    return lhs.fragmentSize_ref() < rhs.fragmentSize_ref();
  }
  if (!(lhs.seeds_ref() == rhs.seeds_ref())) {
    return lhs.seeds_ref() < rhs.seeds_ref();
  }
  return false;
}

const ::std::vector<::std::int64_t>& BloomFilterPersistentData::get_seeds() const& {
  return seeds;
}

::std::vector<::std::int64_t> BloomFilterPersistentData::get_seeds() && {
  return std::move(seeds);
}


void swap(BloomFilterPersistentData& a, BloomFilterPersistentData& b) {
  using ::std::swap;
  swap(a.numFilters_ref().value(), b.numFilters_ref().value());
  swap(a.hashTableBitSize_ref().value(), b.hashTableBitSize_ref().value());
  swap(a.filterByteSize_ref().value(), b.filterByteSize_ref().value());
  swap(a.fragmentSize_ref().value(), b.fragmentSize_ref().value());
  swap(a.seeds_ref().value(), b.seeds_ref().value());
}

template void BloomFilterPersistentData::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t BloomFilterPersistentData::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t BloomFilterPersistentData::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t BloomFilterPersistentData::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void BloomFilterPersistentData::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t BloomFilterPersistentData::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t BloomFilterPersistentData::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t BloomFilterPersistentData::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::cachelib::serialization

namespace facebook { namespace cachelib { namespace serialization { namespace {
FOLLY_MAYBE_UNUSED FOLLY_ERASE void validateAdapters() {
}
}}}} // facebook::cachelib::serialization
